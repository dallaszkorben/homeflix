# Code generated by Amazon Q with the  below prompt:

#WiFi Configuration Tool Prompt
#Create a Python application with a graphical user interface for configuring WiFi on a Raspberry Pi or similar Linux device. The application should allow users to:
#- Scan for available wireless networks
#- Select a network, enter credentials, and test the connection
#- Configure a static IP address
#- Save the configuration to system files
#
#Technical Requirements
#GUI Components
#- Create a Tkinter-based interface with:
#    Interface dropdown (to select wireless interface like wlan0)
#    WiFi network dropdown (populated by scanning)
#    Password field with show/hide toggle
#    IP address field with validation
#    Error and status message display areas (scrollable text widgets)
#    Scan, OK, and Cancel buttons
#- Core Functionality
#  1. Interface Detection :
#      Automatically detect wireless interfaces
#      Default to wlan0 if none found
#      Allow user selection via dropdown
#      2. Network Scanning :
#      Implement a scan button to refresh available networks
#      Sort networks by signal strength
#      Display networks in a dropdown
#      Bring up interface before scanning ( ifconfig <interface> up)
#      Handle "interface does not support scanning" errors
#  3. Connection Testing :
#      Test WiFi credentials when focus leaves password field
#      Use temporary wpa_supplicant instance for testing
#      Detect network IP range and suggest appropriate static IP
#      Show connection status in message area
#  4. IP Configuration :
#      Validate IP address format
#      Allow setting static IP with preferred last segment (default 200)
#      Update IP suggestion based on detected network
#  5. Configuration Saving :
#      Save WiFi credentials to /etc/wpa_supplicant/wpa_supplicant.conf [1]
#      Save network interface config to /etc/network/interfaces
#      Restart network interface after saving
#- UI Behavior
#  1. Field Management :
#      Disable all UI elements during operations (scanning, testing, saving)
#      Re-enable elements when operations complete
#      Clear error/message boxes when appropriate (new scan, interface change)
#      Enable OK button only when all validations pass
#  2. Threading :
#      Use background threads for network operations
#      Update UI from background threads using root.after()
#      Prevent UI freezing during operations
#  3. Keyboard Navigation :
#      Support Enter key to move between fields
#      Support Escape key to close application
#  - Implementation Details
#      Use template files for wpa_supplicant.conf and interfaces [2]
#      Use sudo for system commands requiring elevated privileges
#      Implement proper error handling and user feedback
#      Ensure clean termination of background processes
#      Support showing/hiding password with checkbox
#
#Validate all user inputs before saving
#The application should be robust against network errors, provide clear feedback to users, and ensure proper configuration of WiFi settings on Linux systems.

import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import os
import shutil
import subprocess
import re
import threading
import ipaddress  # For IP address validation
import time

class WifiConfigApp:
    def __init__(self, root):

        # Set preferred lowest segment of IP address
        self.preferred_ip_segment = "200"

        # Get the directory where the script is located
        script_dir = os.path.dirname(os.path.abspath(__file__))

        # Define paths relative to the script location
        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')

        self.interface_path = '/etc/network/interfaces'
        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'

        self.root = root
        self.root.title("Raspberry Pi Wi-Fi Configuration")
        self.root.geometry("780x540")  # Increased width to accommodate wider message boxes

        # Get the default background color of the root window
        bg_color = root.cget("background")

        # Lists to store interfaces and Wi-Fi networks
        self.interfaces = []
        self.wifi_list = []

        # Create frame for form elements
        form_frame = tk.Frame(root, padx=20, pady=20)
        form_frame.pack(fill=tk.BOTH, expand=True)

        # Interface selection dropdown
        tk.Label(form_frame, text="Interface:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.interface_var = tk.StringVar()
        self.interface_dropdown = ttk.Combobox(form_frame, textvariable=self.interface_var, width=10, state="readonly")
        self.interface_dropdown.grid(row=0, column=1, sticky=tk.W, pady=5)
        self.interface_dropdown.bind("<<ComboboxSelected>>", lambda event: self.interface_changed())

        # Wi-Fi name dropdown
        tk.Label(form_frame, text="Wi-Fi Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.wifi_name = tk.StringVar()
        self.wifi_dropdown = ttk.Combobox(form_frame, textvariable=self.wifi_name, width=28, state="readonly")
        self.wifi_dropdown.grid(row=1, column=1, sticky=tk.W, pady=5)

        # Scan button
        self.scan_button = tk.Button(form_frame, text="Scan", width=5, command=self.scan_networks)
        self.scan_button.grid(row=1, column=2, padx=5, sticky=tk.W)

        # Bind Enter key to move to next field
        self.wifi_dropdown.bind("<Return>", lambda event: self.password_entry.focus_set())

        # Password field
        tk.Label(form_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.password = tk.StringVar()
        self.password_entry = tk.Entry(form_frame, textvariable=self.password, width=30)
        self.password_entry.grid(row=2, column=1, sticky=tk.W, pady=5)

        # Bind Enter key to move to IP address field
        self.password_entry.bind("<Return>", lambda event: self.ip_entry.focus_set())

        # Bind FocusOut to test WiFi connection
        self.password_entry.bind("<FocusOut>", self.test_wifi_connection)

        # Add a flag to track connection success
        self.connection_successful = False

        # Hide password checkbox (unchecked by default to show password)
        self.hide_password = tk.BooleanVar(value=False)  # Default is to show password
        self.hide_checkbox = tk.Checkbutton(form_frame, text="Hide", variable=self.hide_password,
                                           command=self.toggle_password_visibility)
        self.hide_checkbox.grid(row=2, column=2, padx=5, sticky=tk.W)

        # IP Address field with validation
        tk.Label(form_frame, text="IP Address:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.ip_address = tk.StringVar(value=f"192.168.1.{self.preferred_ip_segment}")  # Default value with preferred segment
        self.ip_entry = tk.Entry(form_frame, textvariable=self.ip_address, width=30)
        self.ip_entry.grid(row=3, column=1, sticky=tk.W, pady=5)

        # Add validation when focus leaves the IP field
        self.ip_entry.bind("<FocusOut>", self.validate_ip_address)

        # Flag to track if IP is valid
        self.ip_valid = False

        # Initialize password field visibility
        self.toggle_password_visibility()

        # Button frame
        button_frame = tk.Frame(form_frame)
        button_frame.grid(row=4, column=0, columnspan=2, pady=10)

        # OK button (initially disabled)
        self.ok_button = tk.Button(button_frame, text="OK", width=10, command=self.save_config, state=tk.DISABLED)
        self.ok_button.pack(side=tk.LEFT, padx=10)
        self.ok_button.bind("<Return>", lambda event: self.save_config())

        # Cancel button
        self.cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.root.destroy)
        self.cancel_button.pack(side=tk.LEFT, padx=10)
        self.cancel_button.bind("<Return>", lambda event: self.root.destroy())

        # Error message text area (below buttons) - 1.5 times wider
        tk.Label(form_frame, text="Errors:").grid(row=5, column=0, sticky=tk.NW, pady=(10, 0))
        self.error_text = scrolledtext.ScrolledText(form_frame, width=80, height=6,
                                                  wrap=tk.WORD, fg="red", bg=bg_color)
        self.error_text.grid(row=5, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(10, 0))
        self.error_text.config(state=tk.DISABLED)  # Make it read-only

        # Status message text area (below error area) - 1.5 times wider
        tk.Label(form_frame, text="Messages:").grid(row=6, column=0, sticky=tk.NW, pady=(5, 0))
        self.message_text = scrolledtext.ScrolledText(form_frame, width=80, height=8,
                                                    wrap=tk.WORD, fg="blue", bg=bg_color)
        self.message_text.grid(row=6, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(5, 0))
        self.message_text.config(state=tk.DISABLED)  # Make it read-only

        # Bind events to check if all fields have content and IP is valid
        self.wifi_name.trace("w", self.check_fields)
        self.password.trace("w", self.check_fields)
        self.ip_address.trace("w", self.validate_ip_on_change)

        # Bind Escape key to close the window
        self.root.bind("<Escape>", lambda event: self.root.destroy())

        # Find available interfaces and start scanning
        self.find_interfaces()

    def disable_ui_elements(self):
        """Disable all UI elements during operations"""
        self.interface_dropdown.config(state=tk.DISABLED)
        self.wifi_dropdown.config(state=tk.DISABLED)
        self.password_entry.config(state=tk.DISABLED)
        self.ip_entry.config(state=tk.DISABLED)
        self.scan_button.config(state=tk.DISABLED)
        self.ok_button.config(state=tk.DISABLED)
        self.hide_checkbox.config(state=tk.DISABLED)

    def enable_ui_elements(self):
        """Re-enable UI elements after operations"""
        self.interface_dropdown.config(state="readonly")
        self.wifi_dropdown.config(state="readonly")
        self.password_entry.config(state=tk.NORMAL)
        self.ip_entry.config(state=tk.NORMAL)
        self.scan_button.config(state=tk.NORMAL)
        self.hide_checkbox.config(state=tk.NORMAL)
        # OK button state depends on field validation, so call check_fields
        self.check_fields()

    def test_wifi_connection(self, event=None):
        """Test connection to the selected WiFi when leaving password field"""
        wifi_name = self.wifi_name.get()
        password = self.password.get()
        interface = self.interface_var.get()

        if not wifi_name or not password:
            return False

        # Clear error messages before starting the test
        self.clear_error_messages()
        self.add_status_message(f"Testing connection to {wifi_name}...")

        # Disable UI elements during connection test
        self.disable_ui_elements()

        # Start connection test in a separate thread
        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
                        daemon=True).start()
        return True

    def _test_connection_thread(self, wifi_name, password, interface):
        """Background thread for testing WiFi connection"""
        connection_success = False
        temp_dir = "/tmp/wpa_test"
        detected_ip_range = None

        try:
            # Create a temporary control directory for wpa_supplicant
            os.makedirs(temp_dir, exist_ok=True)

            # Start a temporary wpa_supplicant instance for testing
            self.root.after(0, lambda: self.add_status_message("Starting temporary wpa_supplicant..."))

            # Kill any existing wpa_supplicant on this interface
            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
            time.sleep(1)

            # Start wpa_supplicant in the background
            wpa_process = subprocess.Popen(
                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            time.sleep(4)  # Give it time to start

            # Add the network using wpa_cli
            self.root.after(0, lambda: self.add_status_message("Adding network..."))
            add_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
                capture_output=True, text=True
            )
            self.root.after(0, lambda: self.add_status_message(f'add network result:\n{add_result.stdout}'))

            # Extract the network ID from the output (last line)
            network_id = add_result.stdout.strip().split('\n')[-1]

            time.sleep(1)

            # Set the network SSID
            ssid_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
                capture_output=True, text=True
            )
            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{ssid_result.stdout}'))

            # Set the network password
            password_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
                capture_output=True, text=True
            )
            self.root.after(0, lambda: self.add_status_message(f'password result:\n{password_result.stdout}'))

            # Enable the network
            self.root.after(0, lambda: self.add_status_message("Attempting to connect..."))
            status_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
                capture_output=True, text=True
            )
            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{status_result.stdout}'))

            # Poll for connection status every 2 seconds, up to 20 seconds
            max_wait_time = 20  # seconds
            poll_interval = 2    # seconds
            elapsed_time = 0

            while elapsed_time < max_wait_time:
                # Check connection status
                status_result = subprocess.run(
                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
                    capture_output=True, text=True
                )

                # Check if we're connected
                if "wpa_state=COMPLETED" in status_result.stdout:
                    connection_success = True
                    self.root.after(0, lambda: self.add_status_message("WiFi credentials are valid!"))

                    # Try to get an IP address via DHCP to determine the network's IP range
                    self.root.after(0, lambda: self.add_status_message("Requesting temporary IP to detect network range..."))

                    # Run dhclient to get an IP address
                    dhcp_result = subprocess.run(
                        ["sudo", "dhclient", "-1", interface],
                        capture_output=True, text=True
                    )

                    # Check the assigned IP address
                    ip_result = subprocess.run(
                        ["ip", "addr", "show", interface],
                        capture_output=True, text=True
                    )

                    # Extract IP address using regex
                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
                    if ip_match:
                        assigned_ip = ip_match.group(1)
                        # Extract the network prefix (e.g., 192.168.1)
                        ip_parts = assigned_ip.split('.')
                        if len(ip_parts) == 4:
                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
                            self.root.after(0, lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))

                            # Update the IP address suggestion with preferred segment
                            if detected_ip_range:
                                self.root.after(0, lambda range=detected_ip_range: self.update_ip_suggestion(range))
                    break

                # Wait before checking again
                time.sleep(poll_interval)
                elapsed_time += poll_interval
                self.root.after(0, lambda: self.add_status_message(f"Waiting for connection... ({elapsed_time}/{max_wait_time}s)"))

            if not connection_success:
                self.root.after(0, lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))

        except Exception as e:
            error_msg = f"WiFi connection test failed: {str(e)}"
            self.root.after(0, lambda: self.add_error_message(error_msg))

        finally:
            # Release the DHCP lease if we requested one
            if connection_success:
                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)

            # Clean up - terminate wpa_supplicant
            self.root.after(0, lambda: self.add_status_message("Cleaning up test connection..."))
            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)

            # Remove temporary directory
            try:
                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
            except:
                pass

            # Re-enable UI elements
            self.root.after(0, lambda: self.enable_ui_elements())

            # Update connection status and check if OK button should be enabled
            self.root.after(0, lambda: self._update_connection_status(connection_success))

    def update_ip_suggestion(self, ip_range):
        """Update the IP address field with a suggestion based on the detected network range"""
        suggested_ip = f"{ip_range}.{self.preferred_ip_segment}"  # Use preferred segment
        self.ip_address.set(suggested_ip)
        self.validate_ip_on_change()  # Validate the new IP

    def _update_connection_status(self, connection_success):
        """Update the connection status and check if OK button should be enabled"""
        self.connection_successful = connection_success
        self.check_fields()

    def validate_ip_on_change(self, *args):
        """Validate IP address whenever it changes (but don't show errors)"""
        ip = self.ip_address.get()

        # Check if IP is valid
        try:
            # Try to create an IPv4Address object to validate
            ipaddress.IPv4Address(ip)
            self.ip_valid = True
        except ValueError:
            # If not a valid IP, check if it's a partial IP (like "192.168.")
            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
                # It's a partial IP, which is fine while typing
                self.ip_valid = False
            else:
                # Invalid IP format, but don't show error yet
                self.ip_valid = False

        # Update OK button state
        self.check_fields()

    def validate_ip_address(self, event=None):
        """Validate the IP address when focus leaves the field"""
        ip = self.ip_address.get()

        # Clear any previous IP-related error messages
        self.clear_specific_error_messages("IP address")

        # Check if IP is valid
        try:
            # Try to create an IPv4Address object to validate
            ipaddress.IPv4Address(ip)
            self.ip_valid = True
            self.check_fields()
            return True
        except ValueError:
            # If not a valid IP, check if it's a partial IP (like "192.168.")
            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
                # It's a partial IP, which is fine while typing
                self.ip_valid = False
                self.check_fields()
                return False
            else:
                # Invalid IP format - show error message now that focus has left
                error_msg = f"Invalid IP address format: {ip}"
                self.add_error_message(error_msg)
                self.ip_valid = False
                self.check_fields()
                return False

    def clear_specific_error_messages(self, keyword):
        """Clear error messages containing a specific keyword"""
        self.error_text.config(state=tk.NORMAL)

        # Get all lines
        lines = self.error_text.get(1.0, tk.END).split('\n')

        # Filter out lines containing the keyword
        filtered_lines = [line for line in lines if keyword not in line]

        # Clear and reinsert filtered content
        self.error_text.delete(1.0, tk.END)
        self.error_text.insert(tk.END, '\n'.join(filtered_lines))

        self.error_text.config(state=tk.DISABLED)

    def add_error_message(self, message):
        """Add an error message to the error text area"""
        self.error_text.config(state=tk.NORMAL)  # Enable editing
        self.error_text.insert(tk.END, message + "\n")
        self.error_text.see(tk.END)  # Scroll to the end
        self.error_text.config(state=tk.DISABLED)  # Disable editing again

    def clear_error_messages(self):
        """Clear all error messages"""
        self.error_text.config(state=tk.NORMAL)
        self.error_text.delete(1.0, tk.END)
        self.error_text.config(state=tk.DISABLED)

    def add_status_message(self, message):
        """Add a status message to the message text area"""
        self.message_text.config(state=tk.NORMAL)  # Enable editing
        self.message_text.insert(tk.END, message + "\n")
        self.message_text.see(tk.END)  # Scroll to the end
        self.message_text.config(state=tk.DISABLED)  # Disable editing again

    def clear_status_messages(self):
        """Clear all status messages"""
        self.message_text.config(state=tk.NORMAL)
        self.message_text.delete(1.0, tk.END)
        self.message_text.config(state=tk.DISABLED)

    def interface_changed(self):
        """Handle interface selection change"""
        # Clear the Wi-Fi dropdown
        self.wifi_dropdown.set('')
        self.wifi_dropdown['values'] = []
        self.wifi_list = []

        # Clear error and message boxes
        self.clear_error_messages()
        self.clear_status_messages()

        # Disable UI elements during scan
        self.disable_ui_elements()

        # Start scanning with the new interface
        self.scan_networks()

    def find_interfaces(self):
        """Find available network interfaces"""
        status_msg = "Finding network interfaces..."
        self.add_status_message(status_msg)

        # Disable UI elements during interface detection
        self.disable_ui_elements()

        # Start in a separate thread to avoid freezing the UI
        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()

    def _find_interfaces_thread(self):
        """Background thread for finding interfaces"""
        try:
            # Get list of wireless interfaces
            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
            all_interfaces = output.strip().split()

            # Filter for wireless interfaces (typically wlan*)
            self.interfaces = [iface for iface in all_interfaces if
                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
                              iface.startswith("wlan")]

            # Update the dropdown on the main thread
            self.root.after(0, self._update_interface_dropdown)

        except Exception as e:
            error_msg = f"Interface detection error: {str(e)}"
            # Update error message on the main thread
            self.root.after(0, lambda: self.add_error_message(error_msg))
            self.root.after(0, lambda: self.enable_ui_elements())

    def _update_interface_dropdown(self):
        """Update the interface dropdown with found interfaces"""
        if not self.interfaces:
            # If no wireless interfaces found, add a default one
            self.interfaces = ["wlan0"]
            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")

        self.interface_dropdown['values'] = self.interfaces

        # Try to select wlan0 by default, or the first available interface
        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
        self.interface_var.set(default_interface)

        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
        self.add_status_message(status_msg)

        # Start scanning with the selected interface
        self.scan_networks()

    def scan_networks(self):
        """Scan for available Wi-Fi networks using selected interface"""
        interface = self.interface_var.get()
        if not interface:
            return

        # Clear error and message boxes
        self.clear_error_messages()
        self.clear_status_messages()

        status_msg = f"Scanning for networks on {interface}..."
        self.add_status_message(status_msg)

        # Disable UI elements during scan
        self.disable_ui_elements()

        # Start scanning in a separate thread to avoid freezing the UI
        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()

    def _scan_thread(self, interface):
        """Background thread for network scanning"""
        try:
            # First bring up the interface to ensure it's active
            self.root.after(0, lambda: self.add_status_message(f"Bringing up interface {interface}..."))
            ifconfig_result=subprocess.run(["sudo", "ifconfig", interface, "up"], capture_output=True, text=True, check=True)
            time.sleep(4)  # Give it time to initialize

            # Run iwlist scan on the selected interface
            self.root.after(0, lambda: self.add_status_message(f"Scanning for networks..."))
            iwlist_result = subprocess.check_output(["sudo", "iwlist", interface, "scan"], universal_newlines=True)
            #self.root.after(0, lambda: self.add_status_message(f'iwlist scan result:\n{iwlist_result}'))

            # Extract networks and their signal levels
            networks_with_signal = []

            # Split the iwlist_result by "Cell" to process each network separately
            cells = iwlist_result.split("Cell ")

            for cell in cells[1:]:  # Skip the first element (header)
                essid_match = re.search(r'ESSID:"(.*?)"', cell)
                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)

                if essid_match and signal_match:
                    essid = essid_match.group(1)

                    # Skip empty or null-filled SSIDs
                    if not essid or '\\x00' in essid:
                        continue

                    signal_level = int(signal_match.group(1))
                    networks_with_signal.append((essid, signal_level))

            # Sort networks by signal strength (highest first)
            networks_with_signal.sort(key=lambda x: x[1], reverse=True)

            # Extract just the network names, keeping the sorted order
            self.wifi_list = [network[0] for network in networks_with_signal]

            # Update the dropdown on the main thread
            self.root.after(0, self._update_dropdown)

        except subprocess.CalledProcessError as e:
            error_msg = f"Scan error: {e.stderr if hasattr(e, 'stderr') else str(e)}"
            # Update error message on the main thread
            self.root.after(0, lambda: self.add_error_message(error_msg))
            self.root.after(0, lambda: self.enable_ui_elements())
        except Exception as e:
            error_msg = f"Scan error: {str(e)}"
            # Update error message on the main thread
            self.root.after(0, lambda: self.add_error_message(error_msg))
            self.root.after(0, lambda: self.enable_ui_elements())

    def _update_dropdown(self):
        """Update the dropdown with found networks"""
        self.wifi_dropdown['values'] = self.wifi_list

        if self.wifi_list:
            self.wifi_dropdown.current(0)  # Select the first (strongest) network
            status_msg = f"Found {len(self.wifi_list)} networks"
            self.add_status_message(status_msg)
        else:
            error_msg = "No networks found"
            self.add_error_message(error_msg)

        # Re-enable UI elements
        self.enable_ui_elements()

    def toggle_password_visibility(self):
        """Toggle password visibility based on checkbox state"""
        if self.hide_password.get():
            self.password_entry.config(show="*")
        else:
            self.password_entry.config(show="")

    def check_fields(self, *args):
        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
        if (self.wifi_name.get() and
            self.password.get() and
            self.ip_address.get() and
            self.ip_valid and
            self.connection_successful):
            self.ok_button.config(state=tk.NORMAL)
        else:
            self.ok_button.config(state=tk.DISABLED)

    def save_config(self):
        """Save the Wi-Fi configuration to the specified file"""
        wifi_name = self.wifi_name.get()
        password = self.password.get()
        ip_address = self.ip_address.get()
        interface = self.interface_var.get()

        # Temporarily disable the OK button during processing
        self.disable_ui_elements()

        success = True
        wifi_success = False
        interface_success = False
        network_restart_success = False

        try:
            # Read the template wifi_file
            with open(self.temp_wifi_path, 'r') as file:
                wifi_content = file.read()

            # Replace placeholders with user input
            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
            wifi_content = wifi_content.replace("<password>", password)

            # Create a temporary file with the content
            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
            with open(temp_wifi_file, 'w') as file:
                file.write(wifi_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_wifi_file, self.wifi_path],
                capture_output=True, text=True
            )

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_wifi_file)

            wifi_success = True
            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
            self.add_status_message(status_msg)
            # Clear error messages on success
            self.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
            self.add_error_message(error_msg)
            success = False

        try:
            # Read and update the interface template
            with open(self.temp_interface_path, 'r') as file:
                interface_content = file.read()

            # Replace IP address placeholder with user input
            interface_content = interface_content.replace("<address>", ip_address)

            # Create a temporary file with the content
            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
            with open(temp_interface_file, 'w') as file:
                file.write(interface_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_interface_file, self.interface_path],
                capture_output=True, text=True
            )

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_interface_file)

            interface_success = True
            status_msg = f"Network interface configuration saved to {self.interface_path}"
            self.add_status_message(status_msg)
            # Clear error messages on success
            if not wifi_success:  # Only clear if not already cleared
                self.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save interface configuration: {str(e)}"
            self.add_error_message(error_msg)
            success = False

        # If both configurations were successful, restart the network interface
        if wifi_success and interface_success:
            try:
                self.add_status_message(f"Bringing down interface {interface}...")
                # First bring down the interface
                result = subprocess.run(
                    ["sudo", "ifdown", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")

                self.add_status_message(f"Bringing up interface {interface}...")
                # Then bring it back up with the new configuration
                result = subprocess.run(
                    ["sudo", "ifup", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    raise Exception(f"ifup command failed: {result.stderr}")

                network_restart_success = True
                self.add_status_message(f"Successfully restarted interface {interface}")
                # Clear error messages on success
                self.clear_error_messages()

            except Exception as e:
                error_msg = f"Failed to restart network interface: {str(e)}"
                self.add_error_message(error_msg)
                success = False

        # Final status message
        if success and network_restart_success:
            self.add_status_message("Configuration completed and network restarted successfully!")
        elif success:
            self.add_error_message("Configuration completed successfully, but network restart failed.")
        else:
            if wifi_success:
                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
            elif interface_success:
                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
            else:
                self.add_error_message("Configuration failed completely.")

        # Re-enable the UI elements
        self.enable_ui_elements()

if __name__ == "__main__":
    root = tk.Tk()
    app = WifiConfigApp(root)
    root.mainloop()















#import tkinter as tk
#from tkinter import messagebox, ttk, scrolledtext
#import os
#import shutil
#import subprocess
#import re
#import threading
#import ipaddress  # For IP address validation
#import time
#
#class WifiConfigApp:
#    def __init__(self, root):
#
#        # Set preferred lowest segment of IP address
#        self.preferred_ip_segment = "200"
#
#        # Get the directory where the script is located
#        script_dir = os.path.dirname(os.path.abspath(__file__))
#
#        # Define paths relative to the script location
#        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
#        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')
#
#        self.interface_path = '/etc/network/interfaces'
#        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'
#
#        self.root = root
#        self.root.title("Raspberry Pi Wi-Fi Configuration")
#        self.root.geometry("780x540")  # Increased width to accommodate wider message boxes
#
#        # Get the default background color of the root window
#        bg_color = root.cget("background")
#
#        # Lists to store interfaces and Wi-Fi networks
#        self.interfaces = []
#        self.wifi_list = []
#
#        # Create frame for form elements
#        form_frame = tk.Frame(root, padx=20, pady=20)
#        form_frame.pack(fill=tk.BOTH, expand=True)
#
#        # Interface selection dropdown
#        tk.Label(form_frame, text="Interface:").grid(row=0, column=0, sticky=tk.W, pady=5)
#        self.interface_var = tk.StringVar()
#        self.interface_dropdown = ttk.Combobox(form_frame, textvariable=self.interface_var, width=10, state="readonly")
#        self.interface_dropdown.grid(row=0, column=1, sticky=tk.W, pady=5)
#        self.interface_dropdown.bind("<<ComboboxSelected>>", lambda event: self.interface_changed())
#
#        # Wi-Fi name dropdown
#        tk.Label(form_frame, text="Wi-Fi Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
#        self.wifi_name = tk.StringVar()
#        self.wifi_dropdown = ttk.Combobox(form_frame, textvariable=self.wifi_name, width=28, state="readonly")
#        self.wifi_dropdown.grid(row=1, column=1, sticky=tk.W, pady=5)
#
#        # Scan button
#        self.scan_button = tk.Button(form_frame, text="Scan", width=5, command=self.scan_networks)
#        self.scan_button.grid(row=1, column=2, padx=5, sticky=tk.W)
#
#        # Bind Enter key to move to next field
#        self.wifi_dropdown.bind("<Return>", lambda event: self.password_entry.focus_set())
#
#        # Password field
#        tk.Label(form_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
#        self.password = tk.StringVar()
#        self.password_entry = tk.Entry(form_frame, textvariable=self.password, width=30)
#        self.password_entry.grid(row=2, column=1, sticky=tk.W, pady=5)
#
#        # Bind Enter key to move to IP address field
#        self.password_entry.bind("<Return>", lambda event: self.ip_entry.focus_set())
#
#        # Bind FocusOut to test WiFi connection
#        self.password_entry.bind("<FocusOut>", self.test_wifi_connection)
#
#        # Add a flag to track connection success
#        self.connection_successful = False
#
#        # Hide password checkbox (unchecked by default to show password)
#        self.hide_password = tk.BooleanVar(value=False)  # Default is to show password
#        self.hide_checkbox = tk.Checkbutton(form_frame, text="Hide", variable=self.hide_password,
#                                           command=self.toggle_password_visibility)
#        self.hide_checkbox.grid(row=2, column=2, padx=5, sticky=tk.W)
#
#        # IP Address field with validation
#        tk.Label(form_frame, text="IP Address:").grid(row=3, column=0, sticky=tk.W, pady=5)
#        self.ip_address = tk.StringVar(value=f"192.168.1.{self.preferred_ip_segment}")  # Default value with preferred segment
#        self.ip_entry = tk.Entry(form_frame, textvariable=self.ip_address, width=30)
#        self.ip_entry.grid(row=3, column=1, sticky=tk.W, pady=5)
#
#        # Add validation when focus leaves the IP field
#        self.ip_entry.bind("<FocusOut>", self.validate_ip_address)
#
#        # Flag to track if IP is valid
#        self.ip_valid = False
#
#        # Initialize password field visibility
#        self.toggle_password_visibility()
#
#        # Button frame
#        button_frame = tk.Frame(form_frame)
#        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
#
#        # OK button (initially disabled)
#        self.ok_button = tk.Button(button_frame, text="OK", width=10, command=self.save_config, state=tk.DISABLED)
#        self.ok_button.pack(side=tk.LEFT, padx=10)
#        self.ok_button.bind("<Return>", lambda event: self.save_config())
#
#        # Cancel button
#        self.cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.root.destroy)
#        self.cancel_button.pack(side=tk.LEFT, padx=10)
#        self.cancel_button.bind("<Return>", lambda event: self.root.destroy())
#
#        # Error message text area (below buttons) - 1.5 times wider
#        tk.Label(form_frame, text="Errors:").grid(row=5, column=0, sticky=tk.NW, pady=(10, 0))
#        self.error_text = scrolledtext.ScrolledText(form_frame, width=80, height=6,
#                                                  wrap=tk.WORD, fg="red", bg=bg_color)
#        self.error_text.grid(row=5, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(10, 0))
#        self.error_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Status message text area (below error area) - 1.5 times wider
#        tk.Label(form_frame, text="Messages:").grid(row=6, column=0, sticky=tk.NW, pady=(5, 0))
#        self.message_text = scrolledtext.ScrolledText(form_frame, width=80, height=8,
#                                                    wrap=tk.WORD, fg="blue", bg=bg_color)
#        self.message_text.grid(row=6, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(5, 0))
#        self.message_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Bind events to check if all fields have content and IP is valid
#        self.wifi_name.trace("w", self.check_fields)
#        self.password.trace("w", self.check_fields)
#        self.ip_address.trace("w", self.validate_ip_on_change)
#
#        # Bind Escape key to close the window
#        self.root.bind("<Escape>", lambda event: self.root.destroy())
#
#        # Find available interfaces and start scanning
#        self.find_interfaces()
#
#    def test_wifi_connection(self, event=None):
#        """Test connection to the selected WiFi when leaving password field"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        interface = self.interface_var.get()
#
#        if not wifi_name or not password:
#            return False
#
#        # Clear error messages before starting the test
#        self.clear_error_messages()
#        self.add_status_message(f"Testing connection to {wifi_name}...")
#
#        # Disable UI elements during connection test
#        self.password_entry.config(state=tk.DISABLED)
#        self.scan_button.config(state=tk.DISABLED)
#        self.ok_button.config(state=tk.DISABLED)
#        self.wifi_dropdown.config(state=tk.DISABLED)  # Disable WiFi dropdown
#        self.ip_entry.config(state=tk.DISABLED)       # Disable IP entry
#        self.hide_checkbox.config(state=tk.DISABLED)  # Disable hide checkbox
#
#        # Start connection test in a separate thread
#        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
#                        daemon=True).start()
#        return True
#
#    def _test_connection_thread(self, wifi_name, password, interface):
#        """Background thread for testing WiFi connection"""
#        connection_success = False
#        temp_dir = "/tmp/wpa_test"
#        detected_ip_range = None
#
#        try:
#            # Create a temporary control directory for wpa_supplicant
#            os.makedirs(temp_dir, exist_ok=True)
#
#            # Start a temporary wpa_supplicant instance for testing
#            self.root.after(0, lambda: self.add_status_message("Starting temporary wpa_supplicant..."))
#
#            # Kill any existing wpa_supplicant on this interface
#            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
#            time.sleep(1)
#
#            # Start wpa_supplicant in the background
#            wpa_process = subprocess.Popen(
#                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
#                stdout=subprocess.PIPE, stderr=subprocess.PIPE
#            )
#            time.sleep(4)  # Give it time to start
#
#            # Add the network using wpa_cli
#            self.root.after(0, lambda: self.add_status_message("Adding network..."))
#            add_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'add network result:\n{add_result.stdout}'))
#
#            # Extract the network ID from the output (last line)
#            network_id = add_result.stdout.strip().split('\n')[-1]
#
#            time.sleep(1)
#
#            # Set the network SSID
#            ssid_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{ssid_result.stdout}'))
#
#            # Set the network password
#            password_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
#
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'password result:\n{password_result.stdout}'))
#
#            # Enable the network
#            self.root.after(0, lambda: self.add_status_message("Attempting to connect..."))
#            status_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{status_result.stdout}'))
#
#            # Poll for connection status every 2 seconds, up to 20 seconds
#            max_wait_time = 20  # seconds
#            poll_interval = 2    # seconds
#            elapsed_time = 0
#
#            while elapsed_time < max_wait_time:
#                # Check connection status
#                status_result = subprocess.run(
#                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
#                    capture_output=True, text=True
#                )
#
#                # Check if we're connected
#                if "wpa_state=COMPLETED" in status_result.stdout:
#                    connection_success = True
#                    self.root.after(0, lambda: self.add_status_message("WiFi credentials are valid!"))
#
#                    # Try to get an IP address via DHCP to determine the network's IP range
#                    self.root.after(0, lambda: self.add_status_message("Requesting temporary IP to detect network range..."))
#
#                    # Run dhclient to get an IP address
#                    dhcp_result = subprocess.run(
#                        ["sudo", "dhclient", "-1", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Check the assigned IP address
#                    ip_result = subprocess.run(
#                        ["ip", "addr", "show", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Extract IP address using regex
#                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
#                    if ip_match:
#                        assigned_ip = ip_match.group(1)
#                        # Extract the network prefix (e.g., 192.168.1)
#                        ip_parts = assigned_ip.split('.')
#                        if len(ip_parts) == 4:
#                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
#                            self.root.after(0, lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))
#
#                            # Update the IP address suggestion with preferred segment
#                            if detected_ip_range:
#                                self.root.after(0, lambda range=detected_ip_range: self.update_ip_suggestion(range))
#                    break
#
#                # Wait before checking again
#                time.sleep(poll_interval)
#                elapsed_time += poll_interval
#                self.root.after(0, lambda: self.add_status_message(f"Waiting for connection... ({elapsed_time}/{max_wait_time}s)"))
#
#            if not connection_success:
#                self.root.after(0, lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))
#
#        except Exception as e:
#            error_msg = f"WiFi connection test failed: {str(e)}"
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#
#        finally:
#            # Release the DHCP lease if we requested one
#            if connection_success:
#                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)
#
#            # Clean up - terminate wpa_supplicant
#            self.root.after(0, lambda: self.add_status_message("Cleaning up test connection..."))
#            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)
#
#            # Remove temporary directory
#            try:
#                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
#            except:
#                pass
#
#            # Re-enable UI elements
#            self.root.after(0, lambda: self.password_entry.config(state=tk.NORMAL))
#            self.root.after(0, lambda: self.scan_button.config(state=tk.NORMAL))
#            self.root.after(0, lambda: self.wifi_dropdown.config(state="readonly"))  # Re-enable WiFi dropdown
#            self.root.after(0, lambda: self.ip_entry.config(state=tk.NORMAL))       # Re-enable IP entry
#            self.root.after(0, lambda: self.hide_checkbox.config(state=tk.NORMAL))  # Re-enable hide checkbox
#
#            # Update connection status and check if OK button should be enabled
#            self.root.after(0, lambda: self._update_connection_status(connection_success))
#
#    def update_ip_suggestion(self, ip_range):
#        """Update the IP address field with a suggestion based on the detected network range"""
#        suggested_ip = f"{ip_range}.{self.preferred_ip_segment}"  # Use preferred segment
#        self.ip_address.set(suggested_ip)
#        self.validate_ip_on_change()  # Validate the new IP
#
#    def _update_connection_status(self, connection_success):
#        """Update the connection status and check if OK button should be enabled"""
#        self.connection_successful = connection_success
#        self.check_fields()
#
#    def validate_ip_on_change(self, *args):
#        """Validate IP address whenever it changes (but don't show errors)"""
#        ip = self.ip_address.get()
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#            else:
#                # Invalid IP format, but don't show error yet
#                self.ip_valid = False
#
#        # Update OK button state
#        self.check_fields()
#
#    def validate_ip_address(self, event=None):
#        """Validate the IP address when focus leaves the field"""
#        ip = self.ip_address.get()
#
#        # Clear any previous IP-related error messages
#        self.clear_specific_error_messages("IP address")
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#            self.check_fields()
#            return True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#                self.check_fields()
#                return False
#            else:
#                # Invalid IP format - show error message now that focus has left
#                error_msg = f"Invalid IP address format: {ip}"
#                self.add_error_message(error_msg)
#                self.ip_valid = False
#                self.check_fields()
#                return False
#
#    def clear_specific_error_messages(self, keyword):
#        """Clear error messages containing a specific keyword"""
#        self.error_text.config(state=tk.NORMAL)
#
#        # Get all lines
#        lines = self.error_text.get(1.0, tk.END).split('\n')
#
#        # Filter out lines containing the keyword
#        filtered_lines = [line for line in lines if keyword not in line]
#
#        # Clear and reinsert filtered content
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.insert(tk.END, '\n'.join(filtered_lines))
#
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_error_message(self, message):
#        """Add an error message to the error text area"""
#        self.error_text.config(state=tk.NORMAL)  # Enable editing
#        self.error_text.insert(tk.END, message + "\n")
#        self.error_text.see(tk.END)  # Scroll to the end
#        self.error_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_error_messages(self):
#        """Clear all error messages"""
#        self.error_text.config(state=tk.NORMAL)
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_status_message(self, message):
#        """Add a status message to the message text area"""
#        self.message_text.config(state=tk.NORMAL)  # Enable editing
#        self.message_text.insert(tk.END, message + "\n")
#        self.message_text.see(tk.END)  # Scroll to the end
#        self.message_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_status_messages(self):
#        """Clear all status messages"""
#        self.message_text.config(state=tk.NORMAL)
#        self.message_text.delete(1.0, tk.END)
#        self.message_text.config(state=tk.DISABLED)
#
#    def interface_changed(self):
#        """Handle interface selection change"""
#        # Clear the Wi-Fi dropdown
#        self.wifi_dropdown.set('')
#        self.wifi_dropdown['values'] = []
#        self.wifi_list = []
#
#        # Start scanning with the new interface
#        self.scan_networks()
#
#    def find_interfaces(self):
#        """Find available network interfaces"""
#        status_msg = "Finding network interfaces..."
#        self.add_status_message(status_msg)
#
#        # Start in a separate thread to avoid freezing the UI
#        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()
#
#    def _find_interfaces_thread(self):
#        """Background thread for finding interfaces"""
#        try:
#            # Get list of wireless interfaces
#            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
#            all_interfaces = output.strip().split()
#
#            # Filter for wireless interfaces (typically wlan*)
#            self.interfaces = [iface for iface in all_interfaces if
#                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
#                              iface.startswith("wlan")]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_interface_dropdown)
#
#        except Exception as e:
#            error_msg = f"Interface detection error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#
#    def _update_interface_dropdown(self):
#        """Update the interface dropdown with found interfaces"""
#        if not self.interfaces:
#            # If no wireless interfaces found, add a default one
#            self.interfaces = ["wlan0"]
#            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")
#
#        self.interface_dropdown['values'] = self.interfaces
#
#        # Try to select wlan0 by default, or the first available interface
#        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
#        self.interface_var.set(default_interface)
#
#        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
#        self.add_status_message(status_msg)
#
#        # Start scanning with the selected interface
#        self.scan_networks()
#
#    def scan_networks(self):
#        """Scan for available Wi-Fi networks using selected interface"""
#        interface = self.interface_var.get()
#        if not interface:
#            return
#
#        status_msg = f"Scanning for networks on {interface}..."
#        self.add_status_message(status_msg)
#        self.scan_button.config(state=tk.DISABLED)
#
#        # Start scanning in a separate thread to avoid freezing the UI
#        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()
#
#    def _scan_thread(self, interface):
#        """Background thread for network scanning"""
#        try:
#            # Run iwlist scan on the selected interface
#            output = subprocess.check_output(["sudo", "iwlist", interface, "scan"],
#                                           universal_newlines=True)
#
#            # Extract networks and their signal levels
#            networks_with_signal = []
#
#            # Split the output by "Cell" to process each network separately
#            cells = output.split("Cell ")
#
#            for cell in cells[1:]:  # Skip the first element (header)
#                essid_match = re.search(r'ESSID:"(.*?)"', cell)
#                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
#
#                if essid_match and signal_match:
#                    essid = essid_match.group(1)
#
#                    # Skip empty or null-filled SSIDs
#                    if not essid or '\\x00' in essid:
#                        continue
#
#                    signal_level = int(signal_match.group(1))
#                    networks_with_signal.append((essid, signal_level))
#
#            # Sort networks by signal strength (highest first)
#            networks_with_signal.sort(key=lambda x: x[1], reverse=True)
#
#            # Extract just the network names, keeping the sorted order
#            self.wifi_list = [network[0] for network in networks_with_signal]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_dropdown)
#
#        except Exception as e:
#            error_msg = f"Scan error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.scan_button.config(state=tk.NORMAL))
#
#    def _update_dropdown(self):
#        """Update the dropdown with found networks"""
#        self.wifi_dropdown['values'] = self.wifi_list
#
#        if self.wifi_list:
#            self.wifi_dropdown.current(0)  # Select the first (strongest) network
#            status_msg = f"Found {len(self.wifi_list)} networks"
#            self.add_status_message(status_msg)
#            # Clear error messages on successful scan
#            self.clear_error_messages()
#        else:
#            error_msg = "No networks found"
#            self.add_error_message(error_msg)
#
#        self.scan_button.config(state=tk.NORMAL)
#
#    def toggle_password_visibility(self):
#        """Toggle password visibility based on checkbox state"""
#        if self.hide_password.get():
#            self.password_entry.config(show="*")
#        else:
#            self.password_entry.config(show="")
#
#    def check_fields(self, *args):
#        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
#        if (self.wifi_name.get() and
#            self.password.get() and
#            self.ip_address.get() and
#            self.ip_valid and
#            self.connection_successful):
#            self.ok_button.config(state=tk.NORMAL)
#        else:
#            self.ok_button.config(state=tk.DISABLED)
#
#    def save_config(self):
#        """Save the Wi-Fi configuration to the specified file"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        ip_address = self.ip_address.get()
#        interface = self.interface_var.get()
#
#        # Temporarily disable the OK button during processing
#        self.ok_button.config(state=tk.DISABLED)
#
#        success = True
#        wifi_success = False
#        interface_success = False
#        network_restart_success = False
#
#        try:
#            # Read the template wifi_file
#            with open(self.temp_wifi_path, 'r') as file:
#                wifi_content = file.read()
#
#            # Replace placeholders with user input
#            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
#            wifi_content = wifi_content.replace("<password>", password)
#
#            # Create a temporary file with the content
#            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
#            with open(temp_wifi_file, 'w') as file:
#                file.write(wifi_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_wifi_file, self.wifi_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_wifi_file)
#
#            wifi_success = True
#            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        try:
#            # Read and update the interface template
#            with open(self.temp_interface_path, 'r') as file:
#                interface_content = file.read()
#
#            # Replace IP address placeholder with user input
#            interface_content = interface_content.replace("<address>", ip_address)
#
#            # Create a temporary file with the content
#            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
#            with open(temp_interface_file, 'w') as file:
#                file.write(interface_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_interface_file, self.interface_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_interface_file)
#
#            interface_success = True
#            status_msg = f"Network interface configuration saved to {self.interface_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            if not wifi_success:  # Only clear if not already cleared
#                self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save interface configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        # If both configurations were successful, restart the network interface
#        if wifi_success and interface_success:
#            try:
#                self.add_status_message(f"Bringing down interface {interface}...")
#                # First bring down the interface
#                result = subprocess.run(
#                    ["sudo", "ifdown", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")
#
#                self.add_status_message(f"Bringing up interface {interface}...")
#                # Then bring it back up with the new configuration
#                result = subprocess.run(
#                    ["sudo", "ifup", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    raise Exception(f"ifup command failed: {result.stderr}")
#
#                network_restart_success = True
#                self.add_status_message(f"Successfully restarted interface {interface}")
#                # Clear error messages on success
#                self.clear_error_messages()
#
#            except Exception as e:
#                error_msg = f"Failed to restart network interface: {str(e)}"
#                self.add_error_message(error_msg)
#                success = False
#
#        # Final status message
#        if success and network_restart_success:
#            self.add_status_message("Configuration completed and network restarted successfully!")
#        elif success:
#            self.add_error_message("Configuration completed successfully, but network restart failed.")
#        else:
#            if wifi_success:
#                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
#            elif interface_success:
#                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
#            else:
#                self.add_error_message("Configuration failed completely.")
#
#        # Re-enable the OK button
#        self.ok_button.config(state=tk.NORMAL)
#
#if __name__ == "__main__":
#    root = tk.Tk()
#    app = WifiConfigApp(root)
#    root.mainloop()











#class WifiConfigApp:
#    def __init__(self, root):
#
#        # Get the directory where the script is located
#        script_dir = os.path.dirname(os.path.abspath(__file__))
#
#        # Define paths relative to the script location
#        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
#        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')
#
#        self.interface_path = '/etc/network/interfaces'
#        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'
#
#        self.root = root
#        self.root.title("Raspberry Pi Wi-Fi Configuration")
#        self.root.geometry("780x440")  # Increased width to accommodate wider message boxes
#
#        # Get the default background color of the root window
#        bg_color = root.cget("background")
#
#        # Lists to store interfaces and Wi-Fi networks
#        self.interfaces = []
#        self.wifi_list = []
#
#        # Create frame for form elements
#        form_frame = tk.Frame(root, padx=20, pady=20)
#        form_frame.pack(fill=tk.BOTH, expand=True)
#
#        # Interface selection dropdown
#        tk.Label(form_frame, text="Interface:").grid(row=0, column=0, sticky=tk.W, pady=5)
#        self.interface_var = tk.StringVar()
#        self.interface_dropdown = ttk.Combobox(form_frame, textvariable=self.interface_var, width=10, state="readonly")
#        self.interface_dropdown.grid(row=0, column=1, sticky=tk.W, pady=5)
#        self.interface_dropdown.bind("<<ComboboxSelected>>", lambda event: self.interface_changed())
#
#        # Wi-Fi name dropdown
#        tk.Label(form_frame, text="Wi-Fi Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
#        self.wifi_name = tk.StringVar()
#        self.wifi_dropdown = ttk.Combobox(form_frame, textvariable=self.wifi_name, width=28, state="readonly")
#        self.wifi_dropdown.grid(row=1, column=1, sticky=tk.W, pady=5)
#
#        # Scan button
#        self.scan_button = tk.Button(form_frame, text="Scan", width=5, command=self.scan_networks)
#        self.scan_button.grid(row=1, column=2, padx=5, sticky=tk.W)
#
#        # Bind Enter key to move to next field
#        self.wifi_dropdown.bind("<Return>", lambda event: self.password_entry.focus_set())
#
#        # Password field
#        tk.Label(form_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
#        self.password = tk.StringVar()
#        self.password_entry = tk.Entry(form_frame, textvariable=self.password, width=30)
#        self.password_entry.grid(row=2, column=1, sticky=tk.W, pady=5)
#
#        # Bind Enter key to move to IP address field
#        self.password_entry.bind("<Return>", lambda event: self.ip_entry.focus_set())
#
#        # Bind FocusOut to test WiFi connection
#        self.password_entry.bind("<FocusOut>", self.test_wifi_connection)
#
#        # Add a flag to track connection success
#        self.connection_successful = False
#
#        # Hide password checkbox (unchecked by default to show password)
#        self.hide_password = tk.BooleanVar(value=False)  # Default is to show password
#        self.hide_checkbox = tk.Checkbutton(form_frame, text="Hide", variable=self.hide_password,
#                                           command=self.toggle_password_visibility)
#        self.hide_checkbox.grid(row=2, column=2, padx=5, sticky=tk.W)
#
#        # IP Address field with validation
#        tk.Label(form_frame, text="IP Address:").grid(row=3, column=0, sticky=tk.W, pady=5)
#        self.ip_address = tk.StringVar(value="192.168.")  # Default value
#        self.ip_entry = tk.Entry(form_frame, textvariable=self.ip_address, width=30)
#        self.ip_entry.grid(row=3, column=1, sticky=tk.W, pady=5)
#
#        # Add validation when focus leaves the IP field
#        self.ip_entry.bind("<FocusOut>", self.validate_ip_address)
#
#        # Flag to track if IP is valid
#        self.ip_valid = False
#
#        # Initialize password field visibility
#        self.toggle_password_visibility()
#
#        # Button frame
#        button_frame = tk.Frame(form_frame)
#        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
#
#        # OK button (initially disabled)
#        self.ok_button = tk.Button(button_frame, text="OK", width=10, command=self.save_config, state=tk.DISABLED)
#        self.ok_button.pack(side=tk.LEFT, padx=10)
#        self.ok_button.bind("<Return>", lambda event: self.save_config())
#
#        # Cancel button
#        self.cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.root.destroy)
#        self.cancel_button.pack(side=tk.LEFT, padx=10)
#        self.cancel_button.bind("<Return>", lambda event: self.root.destroy())
#
#        # Error message text area (below buttons)
#        tk.Label(form_frame, text="Errors:").grid(row=5, column=0, sticky=tk.NW, pady=(10, 0))
#        self.error_text = scrolledtext.ScrolledText(form_frame, width=80, height=5,
#                                                  wrap=tk.WORD, fg="red", bg=bg_color)
#        self.error_text.grid(row=5, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(10, 0))
#        self.error_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Status message text area (below error area)
#        tk.Label(form_frame, text="Messages:").grid(row=6, column=0, sticky=tk.NW, pady=(5, 0))
#        self.message_text = scrolledtext.ScrolledText(form_frame, width=80, height=5,
#                                                    wrap=tk.WORD, fg="blue", bg=bg_color)
#        self.message_text.grid(row=6, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(5, 0))
#        self.message_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Bind events to check if all fields have content and IP is valid
#        self.wifi_name.trace("w", self.check_fields)
#        self.password.trace("w", self.check_fields)
#        self.ip_address.trace("w", self.validate_ip_on_change)
#
#        # Bind Escape key to close the window
#        self.root.bind("<Escape>", lambda event: self.root.destroy())
#
#        # Find available interfaces and start scanning
#        self.find_interfaces()
#
#    def test_wifi_connection(self, event=None):
#        """Test connection to the selected WiFi when leaving password field"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        interface = self.interface_var.get()
#
#        if not wifi_name or not password:
#            return False
#
#        self.clear_specific_error_messages("WiFi connection")
#        self.add_status_message(f"Testing connection to {wifi_name}...")
#
#        # Disable UI elements during connection test
#        self.password_entry.config(state=tk.DISABLED)
#        self.scan_button.config(state=tk.DISABLED)
#        self.ok_button.config(state=tk.DISABLED)
#
#        # Start connection test in a separate thread
#        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
#                        daemon=True).start()
#
#        return True
#
#    def _test_connection_thread(self, wifi_name, password, interface):
#        """Background thread for testing WiFi connection"""
#        connection_success = False
#        temp_dir = "/tmp/wpa_test"
#
#        try:
#            # Create a temporary control directory for wpa_supplicant
#            os.makedirs(temp_dir, exist_ok=True)
#
#            # Start a temporary wpa_supplicant instance for testing
#            self.root.after(0, lambda: self.add_status_message("Starting temporary wpa_supplicant..."))
#
#            # Kill any existing wpa_supplicant on this interface
#            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
#            time.sleep(2)
#
#            # Start wpa_supplicant in the background
#            wpa_process = subprocess.Popen(
#                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
#                stdout=subprocess.PIPE, stderr=subprocess.PIPE
#            )
#            time.sleep(4)  # Give it time to start
#
#            # Add the network using wpa_cli
#            self.root.after(0, lambda: self.add_status_message("Adding network..."))
#            add_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
#                capture_output=True, text=True
#            )
#            self.add_status_message(f'add network result:\n{add_result.stdout}')
#
#            # Extract the network ID from the output (last line)
#            network_id = add_result.stdout.strip().split('\n')[-1]
#
#            time.sleep(1)
#
#            # Set the network SSID
#            ssid_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
#                capture_output=True, text=True
#            )
#            self.add_status_message(f'ssid result:\n{ssid_result.stdout}')
#
#            # Set the network password
#            password_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
#
#                capture_output=True, text=True
#            )
#            self.add_status_message(f'password result:\n{password_result.stdout}')
#
#            # Enable the network
#            self.root.after(0, lambda: self.add_status_message("Attempting to connect..."))
#            status_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
#                capture_output=True, text=True
#            )
#            self.add_status_message(f'ssid result:\n{status_result.stdout}')
#
#            # Poll for connection status every 2 seconds, up to 20 seconds
#            max_wait_time = 30  # seconds
#            poll_interval = 2   # seconds
#            elapsed_time = 0
#
#            while elapsed_time < max_wait_time:
#                # Check connection status
#                status_result = subprocess.run(
#                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
#                    capture_output=True, text=True
#                )
#
#                # Check if we're connected
#                if "wpa_state=COMPLETED" in status_result.stdout:
#                    connection_success = True
#                    self.root.after(0, lambda: self.clear_error_messages())
#                    self.root.after(0, lambda: self.add_status_message("WiFi credentials are valid!"))
#
#                    # Try to get an IP address via DHCP to determine the network's IP range
#                    self.root.after(0, lambda: self.add_status_message("Requesting temporary IP to detect network range..."))
#
#                    # Run dhclient to get an IP address
#                    dhcp_result = subprocess.run(
#                        ["sudo", "dhclient", "-1", interface],
#                        capture_output=True, text=True
#                    )
#                    self.add_status_message(f'dhclient:\n{dhcp_result.stdout}')
#
#                    # Check the assigned IP address
#                    ip_result = subprocess.run(
#                        ["ip", "addr", "show", interface],
#                        capture_output=True, text=True
#                    )
#                    self.add_status_message(f'ip_result:\n{ip_result.stdout}')
#
#                    # Extract IP address using regex
#                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
#                    if ip_match:
#                        assigned_ip = ip_match.group(1)
#
#                        # Extract the network prefix (e.g., 192.168.1)
#                        ip_parts = assigned_ip.split('.')
#                        if len(ip_parts) == 4:
#                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
#                            self.root.after(0, lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))
#
#                            # Update the default IP address suggestion
#                            if detected_ip_range:
#                                self.root.after(0, lambda range=detected_ip_range: self.update_ip_suggestion(range))
#                    break
#
#                # Wait before checking again
#                time.sleep(poll_interval)
#                elapsed_time += poll_interval
#                self.root.after(0, lambda: self.add_status_message(f"Waiting for connection... ({elapsed_time}/{max_wait_time}s)"))
#
#            if not connection_success:
#                self.root.after(0, lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))
#
#        except Exception as e:
#            error_msg = f"WiFi connection test failed: {str(e)}"
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#        finally:
#            # Release the DHCP lease
#            if connection_success:
#                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)
#
#            # Clean up - terminate wpa_supplicant
#            self.root.after(0, lambda: self.add_status_message("Cleaning up test connection..."))
#            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)
#
#            # Remove temporary directory
#            try:
#                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
#            except:
#                pass
#
#            # Re-enable UI elements
#            self.root.after(0, lambda: self.password_entry.config(state=tk.NORMAL))
#            self.root.after(0, lambda: self.scan_button.config(state=tk.NORMAL))
#
#            # Update connection status and check if OK button should be enabled
#            self.root.after(0, lambda: self._update_connection_status(connection_success))
#
#    # Add this new method to update the IP address suggestion
#    def update_ip_suggestion(self, ip_range):
#        """Update the IP address field with a suggestion based on the detected network range"""
#        current_ip = self.ip_address.get()
#
#        # Only update if the current IP is the default or empty
#        if not current_ip or current_ip == "192.168.":
#            suggested_ip = f"{ip_range}.100"  # Use .100 as a reasonable default
#            self.ip_address.set(suggested_ip)
#            self.validate_ip_on_change()  # Validate the new IP
#
#
#
#    def _update_connection_status(self, connection_success):
#        """Update the connection status and check if OK button should be enabled"""
#        self.connection_successful = connection_success
#        self.check_fields()
#
#    def validate_ip_on_change(self, *args):
#        """Validate IP address whenever it changes (but don't show errors)"""
#        ip = self.ip_address.get()
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#            else:
#                # Invalid IP format, but don't show error yet
#                self.ip_valid = False
#
#        # Update OK button state
#        self.check_fields()
#
#    def validate_ip_address(self, event=None):
#        """Validate the IP address when focus leaves the field"""
#        ip = self.ip_address.get()
#
#        # Clear any previous IP-related error messages
#        self.clear_specific_error_messages("IP address")
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#            self.check_fields()
#            return True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#                self.check_fields()
#                return False
#            else:
#                # Invalid IP format - show error message now that focus has left
#                error_msg = f"Invalid IP address format: {ip}"
#                self.add_error_message(error_msg)
#                self.ip_valid = False
#                self.check_fields()
#                return False
#
#    def clear_specific_error_messages(self, keyword):
#        """Clear error messages containing a specific keyword"""
#        self.error_text.config(state=tk.NORMAL)
#
#        # Get all lines
#        lines = self.error_text.get(1.0, tk.END).split('\n')
#
#        # Filter out lines containing the keyword
#        filtered_lines = [line for line in lines if keyword not in line]
#
#        # Clear and reinsert filtered content
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.insert(tk.END, '\n'.join(filtered_lines))
#
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_error_message(self, message):
#        """Add an error message to the error text area"""
#        self.error_text.config(state=tk.NORMAL)  # Enable editing
#        self.error_text.insert(tk.END, message + "\n")
#        self.error_text.see(tk.END)  # Scroll to the end
#        self.error_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_error_messages(self):
#        """Clear all error messages"""
#        self.error_text.config(state=tk.NORMAL)
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_status_message(self, message):
#        """Add a status message to the message text area"""
#        self.message_text.config(state=tk.NORMAL)  # Enable editing
#        self.message_text.insert(tk.END, message + "\n")
#        self.message_text.see(tk.END)  # Scroll to the end
#        self.message_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_status_messages(self):
#        """Clear all status messages"""
#        self.message_text.config(state=tk.NORMAL)
#        self.message_text.delete(1.0, tk.END)
#        self.message_text.config(state=tk.DISABLED)
#
#    def interface_changed(self):
#        """Handle interface selection change"""
#        # Clear the Wi-Fi dropdown
#        self.wifi_dropdown.set('')
#        self.wifi_dropdown['values'] = []
#        self.wifi_list = []
#
#        # Start scanning with the new interface
#        self.scan_networks()
#
#    def find_interfaces(self):
#        """Find available network interfaces"""
#        status_msg = "Finding network interfaces..."
#        self.add_status_message(status_msg)
#
#        # Start in a separate thread to avoid freezing the UI
#        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()
#
#    def _find_interfaces_thread(self):
#        """Background thread for finding interfaces"""
#        try:
#            # Get list of wireless interfaces
#            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
#            all_interfaces = output.strip().split()
#
#            # Filter for wireless interfaces (typically wlan*)
#            self.interfaces = [iface for iface in all_interfaces if
#                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
#                              iface.startswith("wlan")]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_interface_dropdown)
#
#        except Exception as e:
#            error_msg = f"Interface detection error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#
#    def _update_interface_dropdown(self):
#        """Update the interface dropdown with found interfaces"""
#        if not self.interfaces:
#            # If no wireless interfaces found, add a default one
#            self.interfaces = ["wlan0"]
#            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")
#
#        self.interface_dropdown['values'] = self.interfaces
#
#        # Try to select wlan0 by default, or the first available interface
#        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
#        self.interface_var.set(default_interface)
#
#        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
#        self.add_status_message(status_msg)
#
#        # Start scanning with the selected interface
#        self.scan_networks()
#
#    def scan_networks(self):
#        """Scan for available Wi-Fi networks using selected interface"""
#        interface = self.interface_var.get()
#        if not interface:
#            return
#
#        status_msg = f"Scanning for networks on {interface}..."
#        self.add_status_message(status_msg)
#        self.scan_button.config(state=tk.DISABLED)
#
#        # Start scanning in a separate thread to avoid freezing the UI
#        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()
#
#    def _scan_thread(self, interface):
#        """Background thread for network scanning"""
#        try:
#            # Run iwlist scan on the selected interface
#            output = subprocess.check_output(["sudo", "iwlist", interface, "scan"],
#                                           universal_newlines=True)
#
#            # Extract networks and their signal levels
#            networks_with_signal = []
#
#            # Split the output by "Cell" to process each network separately
#            cells = output.split("Cell ")
#
#            for cell in cells[1:]:  # Skip the first element (header)
#                essid_match = re.search(r'ESSID:"(.*?)"', cell)
#                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
#
#                if essid_match and signal_match:
#                    essid = essid_match.group(1)
#
#                    # Skip empty or null-filled SSIDs
#                    if not essid or '\\x00' in essid:
#                        continue
#
#                    signal_level = int(signal_match.group(1))
#                    networks_with_signal.append((essid, signal_level))
#
#            # Sort networks by signal strength (highest first)
#            networks_with_signal.sort(key=lambda x: x[1], reverse=True)
#
#            # Extract just the network names, keeping the sorted order
#            self.wifi_list = [network[0] for network in networks_with_signal]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_dropdown)
#
#        except Exception as e:
#            error_msg = f"Scan error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.scan_button.config(state=tk.NORMAL))
#
#    def _update_dropdown(self):
#        """Update the dropdown with found networks"""
#        self.wifi_dropdown['values'] = self.wifi_list
#
#        if self.wifi_list:
#            self.wifi_dropdown.current(0)  # Select the first (strongest) network
#            status_msg = f"Found {len(self.wifi_list)} networks"
#            self.add_status_message(status_msg)
#            # Clear error messages on successful scan
#            self.clear_error_messages()
#        else:
#            error_msg = "No networks found"
#            self.add_error_message(error_msg)
#
#        self.scan_button.config(state=tk.NORMAL)
#
#    def toggle_password_visibility(self):
#        """Toggle password visibility based on checkbox state"""
#        if self.hide_password.get():
#            self.password_entry.config(show="*")
#        else:
#            self.password_entry.config(show="")
#
#    def check_fields(self, *args):
#        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
#        if (self.wifi_name.get() and
#            self.password.get() and
#            self.ip_address.get() and
#            self.ip_valid and
#            self.connection_successful):
#            self.ok_button.config(state=tk.NORMAL)
#        else:
#            self.ok_button.config(state=tk.DISABLED)
#
#    def save_config(self):
#        """Save the Wi-Fi configuration to the specified file"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        ip_address = self.ip_address.get()
#        interface = self.interface_var.get()
#
#        # Temporarily disable the OK button during processing
#        self.ok_button.config(state=tk.DISABLED)
#
#        success = True
#        wifi_success = False
#        interface_success = False
#        network_restart_success = False
#
#        try:
#            # Read the template wifi_file
#            with open(self.temp_wifi_path, 'r') as file:
#                wifi_content = file.read()
#
#            # Replace placeholders with user input
#            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
#            wifi_content = wifi_content.replace("<password>", password)
#
#            # Create a temporary file with the content
#            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
#            with open(temp_wifi_file, 'w') as file:
#                file.write(wifi_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_wifi_file, self.wifi_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_wifi_file)
#
#            wifi_success = True
#            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        try:
#            # Read and update the interface template
#            with open(self.temp_interface_path, 'r') as file:
#                interface_content = file.read()
#
#            # Replace IP address placeholder with user input
#            interface_content = interface_content.replace("<address>", ip_address)
#
#            # Create a temporary file with the content
#            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
#            with open(temp_interface_file, 'w') as file:
#                file.write(interface_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_interface_file, self.interface_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_interface_file)
#
#            interface_success = True
#            status_msg = f"Network interface configuration saved to {self.interface_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            if not wifi_success:  # Only clear if not already cleared
#                self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save interface configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        # If both configurations were successful, restart the network interface
#        if wifi_success and interface_success:
#            try:
#                self.add_status_message(f"Bringing down interface {interface}...")
#                # First bring down the interface
#                result = subprocess.run(
#                    ["sudo", "ifdown", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")
#
#                self.add_status_message(f"Bringing up interface {interface}...")
#                # Then bring it back up with the new configuration
#                result = subprocess.run(
#                    ["sudo", "ifup", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    raise Exception(f"ifup command failed: {result.stderr}")
#
#                network_restart_success = True
#                self.add_status_message(f"Successfully restarted interface {interface}")
#                # Clear error messages on success
#                self.clear_error_messages()
#
#            except Exception as e:
#                error_msg = f"Failed to restart network interface: {str(e)}"
#                self.add_error_message(error_msg)
#                success = False
#
#        # Final status message
#        if success and network_restart_success:
#            self.add_status_message("Configuration completed and network restarted successfully!")
#        elif success:
#            self.add_error_message("Configuration completed successfully, but network restart failed.")
#        else:
#            if wifi_success:
#                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
#            elif interface_success:
#                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
#            else:
#                self.add_error_message("Configuration failed completely.")
#
#        # Re-enable the OK button
#        self.ok_button.config(state=tk.NORMAL)
#
#if __name__ == "__main__":
#    root = tk.Tk()
#    app = WifiConfigApp(root)
#    root.mainloop()




#class WifiConfigApp:
#    def __init__(self, root):
#
#        # Get the directory where the script is located
#        script_dir = os.path.dirname(os.path.abspath(__file__))
#
#        # Define paths relative to the script location
#        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
#        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')
#
#        self.interface_path = '/etc/network/interfaces'
#        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'
#
#        self.root = root
#        self.root.title("Raspberry Pi Wi-Fi Configuration")
#        self.root.geometry("780x400")  # Increased width to accommodate wider message boxes
#
#        # Get the default background color of the root window
#        bg_color = root.cget("background")
#
#        # Lists to store interfaces and Wi-Fi networks
#        self.interfaces = []
#        self.wifi_list = []
#
#        # Create frame for form elements
#        form_frame = tk.Frame(root, padx=20, pady=20)
#        form_frame.pack(fill=tk.BOTH, expand=True)
#
#        # Interface selection dropdown
#        tk.Label(form_frame, text="Interface:").grid(row=0, column=0, sticky=tk.W, pady=5)
#        self.interface_var = tk.StringVar()
#        self.interface_dropdown = ttk.Combobox(form_frame, textvariable=self.interface_var, width=10, state="readonly")
#        self.interface_dropdown.grid(row=0, column=1, sticky=tk.W, pady=5)
#        self.interface_dropdown.bind("<<ComboboxSelected>>", lambda event: self.interface_changed())
#
#        # Wi-Fi name dropdown
#        tk.Label(form_frame, text="Wi-Fi Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
#        self.wifi_name = tk.StringVar()
#        self.wifi_dropdown = ttk.Combobox(form_frame, textvariable=self.wifi_name, width=28, state="readonly")
#        self.wifi_dropdown.grid(row=1, column=1, sticky=tk.W, pady=5)
#
#        # Scan button
#        self.scan_button = tk.Button(form_frame, text="Scan", width=5, command=self.scan_networks)
#        self.scan_button.grid(row=1, column=2, padx=5, sticky=tk.W)
#
#        # Bind Enter key to move to next field
#        self.wifi_dropdown.bind("<Return>", lambda event: self.password_entry.focus_set())
#
#        # Password field
#        tk.Label(form_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
#        self.password = tk.StringVar()
#        self.password_entry = tk.Entry(form_frame, textvariable=self.password, width=30)
#        self.password_entry.grid(row=2, column=1, sticky=tk.W, pady=5)
#
#        # Bind Enter key to move to IP address field
#        self.password_entry.bind("<Return>", lambda event: self.ip_entry.focus_set())
#
#        # Hide password checkbox (unchecked by default to show password)
#        self.hide_password = tk.BooleanVar(value=False)  # Default is to show password
#        self.hide_checkbox = tk.Checkbutton(form_frame, text="Hide", variable=self.hide_password,
#                                           command=self.toggle_password_visibility)
#        self.hide_checkbox.grid(row=2, column=2, padx=5, sticky=tk.W)
#
#        # IP Address field with validation
#        tk.Label(form_frame, text="IP Address:").grid(row=3, column=0, sticky=tk.W, pady=5)
#        self.ip_address = tk.StringVar(value="192.168.")  # Default value
#        self.ip_entry = tk.Entry(form_frame, textvariable=self.ip_address, width=30)
#        self.ip_entry.grid(row=3, column=1, sticky=tk.W, pady=5)
#
#        # Add validation when focus leaves the IP field
#        self.ip_entry.bind("<FocusOut>", self.validate_ip_address)
#
#        # Flag to track if IP is valid
#        self.ip_valid = False
#
#        # Initialize password field visibility
#        self.toggle_password_visibility()
#
#        # Button frame
#        button_frame = tk.Frame(form_frame)
#        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
#
#        # OK button (initially disabled)
#        self.ok_button = tk.Button(button_frame, text="OK", width=10, command=self.save_config, state=tk.DISABLED)
#        self.ok_button.pack(side=tk.LEFT, padx=10)
#        self.ok_button.bind("<Return>", lambda event: self.save_config())
#
#        # Cancel button
#        self.cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.root.destroy)
#        self.cancel_button.pack(side=tk.LEFT, padx=10)
#        self.cancel_button.bind("<Return>", lambda event: self.root.destroy())
#
#        # Error message text area (below buttons) - 1.5 times wider
#        tk.Label(form_frame, text="Errors:").grid(row=5, column=0, sticky=tk.NW, pady=(10, 0))
#        self.error_text = scrolledtext.ScrolledText(form_frame, width=80, height=3,
#                                                  wrap=tk.WORD, fg="red", bg=bg_color)
#        self.error_text.grid(row=5, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(10, 0))
#        self.error_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Status message text area (below error area) - 1.5 times wider
#        tk.Label(form_frame, text="Messages:").grid(row=6, column=0, sticky=tk.NW, pady=(5, 0))
#        self.message_text = scrolledtext.ScrolledText(form_frame, width=80, height=3,
#                                                    wrap=tk.WORD, fg="blue", bg=bg_color)
#        self.message_text.grid(row=6, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(5, 0))
#        self.message_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Bind events to check if all fields have content and IP is valid
#        self.wifi_name.trace("w", self.check_fields)
#        self.password.trace("w", self.check_fields)
#        self.ip_address.trace("w", self.validate_ip_on_change)
#
#        # Bind Escape key to close the window
#        self.root.bind("<Escape>", lambda event: self.root.destroy())
#
#        # Find available interfaces and start scanning
#        self.find_interfaces()
#
#    def validate_ip_on_change(self, *args):
#        """Validate IP address whenever it changes (but don't show errors)"""
#        ip = self.ip_address.get()
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#            else:
#                # Invalid IP format, but don't show error yet
#                self.ip_valid = False
#
#        # Update OK button state
#        self.check_fields()
#
#    def validate_ip_address(self, event=None):
#        """Validate the IP address when focus leaves the field"""
#        ip = self.ip_address.get()
#
#        # Clear any previous IP-related error messages
#        self.clear_specific_error_messages("IP address")
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#            self.check_fields()
#            return True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#                self.check_fields()
#                return False
#            else:
#                # Invalid IP format - show error message now that focus has left
#                error_msg = f"Invalid IP address format: {ip}"
#                self.add_error_message(error_msg)
#                self.ip_valid = False
#                self.check_fields()
#                return False
#
#    def clear_specific_error_messages(self, keyword):
#        """Clear error messages containing a specific keyword"""
#        self.error_text.config(state=tk.NORMAL)
#
#        # Get all lines
#        lines = self.error_text.get(1.0, tk.END).split('\n')
#
#        # Filter out lines containing the keyword
#        filtered_lines = [line for line in lines if keyword not in line]
#
#        # Clear and reinsert filtered content
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.insert(tk.END, '\n'.join(filtered_lines))
#
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_error_message(self, message):
#        """Add an error message to the error text area"""
#        self.error_text.config(state=tk.NORMAL)  # Enable editing
#        self.error_text.insert(tk.END, message + "\n")
#        self.error_text.see(tk.END)  # Scroll to the end
#        self.error_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_error_messages(self):
#        """Clear all error messages"""
#        self.error_text.config(state=tk.NORMAL)
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_status_message(self, message):
#        """Add a status message to the message text area"""
#        self.message_text.config(state=tk.NORMAL)  # Enable editing
#        self.message_text.insert(tk.END, message + "\n")
#        self.message_text.see(tk.END)  # Scroll to the end
#        self.message_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_status_messages(self):
#        """Clear all status messages"""
#        self.message_text.config(state=tk.NORMAL)
#        self.message_text.delete(1.0, tk.END)
#        self.message_text.config(state=tk.DISABLED)
#
#    def interface_changed(self):
#        """Handle interface selection change"""
#        # Clear the Wi-Fi dropdown
#        self.wifi_dropdown.set('')
#        self.wifi_dropdown['values'] = []
#        self.wifi_list = []
#
#        # Start scanning with the new interface
#        self.scan_networks()
#
#    def find_interfaces(self):
#        """Find available network interfaces"""
#        status_msg = "Finding network interfaces..."
#        self.add_status_message(status_msg)
#
#        # Start in a separate thread to avoid freezing the UI
#        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()
#
#    def _find_interfaces_thread(self):
#        """Background thread for finding interfaces"""
#        try:
#            # Get list of wireless interfaces
#            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
#            all_interfaces = output.strip().split()
#
#            # Filter for wireless interfaces (typically wlan*)
#            self.interfaces = [iface for iface in all_interfaces if
#                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
#                              iface.startswith("wlan")]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_interface_dropdown)
#
#        except Exception as e:
#            error_msg = f"Interface detection error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#
#    def _update_interface_dropdown(self):
#        """Update the interface dropdown with found interfaces"""
#        if not self.interfaces:
#            # If no wireless interfaces found, add a default one
#            self.interfaces = ["wlan0"]
#            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")
#
#        self.interface_dropdown['values'] = self.interfaces
#
#        # Try to select wlan0 by default, or the first available interface
#        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
#        self.interface_var.set(default_interface)
#
#        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
#        self.add_status_message(status_msg)
#
#        # Start scanning with the selected interface
#        self.scan_networks()
#
#    def scan_networks(self):
#        """Scan for available Wi-Fi networks using selected interface"""
#        interface = self.interface_var.get()
#        if not interface:
#            return
#
#        status_msg = f"Scanning for networks on {interface}..."
#        self.add_status_message(status_msg)
#        self.scan_button.config(state=tk.DISABLED)
#
#        # Start scanning in a separate thread to avoid freezing the UI
#        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()
#
#    def _scan_thread(self, interface):
#        """Background thread for network scanning"""
#        try:
#            # Run iwlist scan on the selected interface
#            output = subprocess.check_output(["sudo", "iwlist", interface, "scan"],
#                                           universal_newlines=True)
#
#            # Extract networks and their signal levels
#            networks_with_signal = []
#
#            # Split the output by "Cell" to process each network separately
#            cells = output.split("Cell ")
#
#            for cell in cells[1:]:  # Skip the first element (header)
#                essid_match = re.search(r'ESSID:"(.*?)"', cell)
#                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
#
#                if essid_match and signal_match:
#                    essid = essid_match.group(1)
#
#                    # Skip empty or null-filled SSIDs
#                    if not essid or '\\x00' in essid:
#                        continue
#
#                    signal_level = int(signal_match.group(1))
#                    networks_with_signal.append((essid, signal_level))
#
#            # Sort networks by signal strength (highest first)
#            networks_with_signal.sort(key=lambda x: x[1], reverse=True)
#
#            # Extract just the network names, keeping the sorted order
#            self.wifi_list = [network[0] for network in networks_with_signal]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_dropdown)
#
#        except Exception as e:
#            error_msg = f"Scan error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.scan_button.config(state=tk.NORMAL))
#
#    def _update_dropdown(self):
#        """Update the dropdown with found networks"""
#        self.wifi_dropdown['values'] = self.wifi_list
#
#        if self.wifi_list:
#            self.wifi_dropdown.current(0)  # Select the first (strongest) network
#            status_msg = f"Found {len(self.wifi_list)} networks"
#            self.add_status_message(status_msg)
#        else:
#            error_msg = "No networks found"
#            self.add_error_message(error_msg)
#
#        self.scan_button.config(state=tk.NORMAL)
#
#    def toggle_password_visibility(self):
#        """Toggle password visibility based on checkbox state"""
#        if self.hide_password.get():
#            self.password_entry.config(show="*")
#        else:
#            self.password_entry.config(show="")
#
#    def check_fields(self, *args):
#        """Enable OK button only if all fields have content and IP is valid"""
#        if (self.wifi_name.get() and
#            self.password.get() and
#            self.ip_address.get() and
#            self.ip_valid):
#            self.ok_button.config(state=tk.NORMAL)
#        else:
#            self.ok_button.config(state=tk.DISABLED)
#
#    def save_config(self):
#        """Save the Wi-Fi configuration to the specified file"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        ip_address = self.ip_address.get()
#        interface = self.interface_var.get()
#
#        # Temporarily disable the OK button during processing
#        self.ok_button.config(state=tk.DISABLED)
#
#        success = True
#        wifi_success = False
#        interface_success = False
#        network_restart_success = False
#
#        try:
#            # Read the template wifi_file
#            with open(self.temp_wifi_path, 'r') as file:
#                wifi_content = file.read()
#
#            # Replace placeholders with user input
#            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
#            wifi_content = wifi_content.replace("<password>", password)
#
#            # Create a temporary file with the content
#            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
#            with open(temp_wifi_file, 'w') as file:
#                file.write(wifi_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_wifi_file, self.wifi_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_wifi_file)
#
#            wifi_success = True
#            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
#            self.add_status_message(status_msg)
#
#        except Exception as e:
#            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        try:
#            # Read and update the interface template
#            with open(self.temp_interface_path, 'r') as file:
#                interface_content = file.read()
#
#            # Replace IP address placeholder with user input
#            interface_content = interface_content.replace("<address>", ip_address)
#
#            # Create a temporary file with the content
#            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
#            with open(temp_interface_file, 'w') as file:
#                file.write(interface_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_interface_file, self.interface_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_interface_file)
#
#            interface_success = True
#            status_msg = f"Network interface configuration saved to {self.interface_path}"
#            self.add_status_message(status_msg)
#
#        except Exception as e:
#            error_msg = f"Failed to save interface configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        # If both configurations were successful, restart the network interface
#        if wifi_success and interface_success:
#            try:
#                self.add_status_message(f"Bringing down interface {interface}...")
#                # First bring down the interface
#                result = subprocess.run(
#                    ["sudo", "ifdown", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")
#
#                self.add_status_message(f"Bringing up interface {interface}...")
#                # Then bring it back up with the new configuration
#                result = subprocess.run(
#                    ["sudo", "ifup", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    raise Exception(f"ifup command failed: {result.stderr}")
#
#                network_restart_success = True
#                self.add_status_message(f"Successfully restarted interface {interface}")
#
#            except Exception as e:
#                error_msg = f"Failed to restart network interface: {str(e)}"
#                self.add_error_message(error_msg)
#                success = False
#
#
#        # Final status message
#        if success and network_restart_success:
#            self.add_status_message("Configuration completed and network restarted successfully!")
#        elif success:
#            self.add_error_message("Configuration completed successfully, but network restart failed.")
#        else:
#            if wifi_success:
#                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
#            elif interface_success:
#                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
#            else:
#                self.add_error_message("Configuration failed completely.")
#
#        # Re-enable the OK button
#        self.ok_button.config(state=tk.NORMAL)
#
#if __name__ == "__main__":
#    root = tk.Tk()
#    app = WifiConfigApp(root)
#    root.mainloop()



