#!/usr/bin/env python3

# Code generated by Amazon Q with the  below prompt:



#!/usr/bin/env python3
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Pango
import os
import shutil
import subprocess
import re
import threading
import ipaddress
import time

class WifiConfigApp:
    def __init__(self):
        # Set preferred lowest segment of IP address
        self.preferred_ip_segment = "200"

        # Get the directory where the script is located
        script_dir = os.path.dirname(os.path.abspath(__file__))

        # Define paths relative to the script location
        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')

        self.interface_path = '/etc/network/interfaces'
        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'

        # Lists to store interfaces and Wi-Fi networks
        self.interfaces = []
        self.wifi_list = []

        # Add a flag to track connection success
        self.connection_successful = False

        # Flag to track if IP is valid
        self.ip_valid = False

        # Build the UI
        self.build_ui()

        # Find available interfaces and start scanning
        self.find_interfaces()

    def build_ui(self):
        # Create main window
        self.window = Gtk.Window(title="Raspberry Pi Wi-Fi Configuration")
        self.window.set_default_size(780, 540)
        self.window.connect("destroy", Gtk.main_quit)

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.set_margin_start(20)
        main_box.set_margin_end(20)
        main_box.set_margin_top(20)
        main_box.set_margin_bottom(20)
        self.window.add(main_box)

        # Create form grid
        form_grid = Gtk.Grid()
        form_grid.set_column_spacing(10)
        form_grid.set_row_spacing(10)
        main_box.pack_start(form_grid, False, False, 0)

        # Interface selection
        interface_label = Gtk.Label(label="Interface:")
        interface_label.set_halign(Gtk.Align.START)
        form_grid.attach(interface_label, 0, 0, 1, 1)

        self.interface_combo = Gtk.ComboBoxText()
        form_grid.attach(self.interface_combo, 1, 0, 1, 1)
        self.interface_combo.connect("changed", self.interface_changed)

        # Wi-Fi name selection
        wifi_label = Gtk.Label(label="Wi-Fi Name:")
        wifi_label.set_halign(Gtk.Align.START)
        form_grid.attach(wifi_label, 0, 1, 1, 1)

        self.wifi_combo = Gtk.ComboBoxText()
        form_grid.attach(self.wifi_combo, 1, 1, 1, 1)
        self.wifi_combo.connect("changed", self.wifi_changed)

        # Scan button
        self.scan_button = Gtk.Button(label="Scan")
        self.scan_button.connect("clicked", self.on_scan_clicked)
        form_grid.attach(self.scan_button, 2, 1, 1, 1)

        # Password field
        password_label = Gtk.Label(label="Password:")
        password_label.set_halign(Gtk.Align.START)
        form_grid.attach(password_label, 0, 2, 1, 1)

        self.password_entry = Gtk.Entry()
        self.password_entry.set_width_chars(30)
        form_grid.attach(self.password_entry, 1, 2, 1, 1)
        self.password_entry.connect("focus-out-event", self.test_wifi_connection)

        # Hide password checkbox
        self.hide_password = Gtk.CheckButton(label="Hide")
        self.hide_password.connect("toggled", self.toggle_password_visibility)
        form_grid.attach(self.hide_password, 2, 2, 1, 1)

        # IP Address field
        ip_label = Gtk.Label(label="IP Address:")
        ip_label.set_halign(Gtk.Align.START)
        form_grid.attach(ip_label, 0, 3, 1, 1)

        self.ip_entry = Gtk.Entry()
        self.ip_entry.set_width_chars(30)
        # Start with empty IP field and make it inactive
        self.ip_entry.set_text("")
        self.ip_entry.set_sensitive(False)
        form_grid.attach(self.ip_entry, 1, 3, 1, 1)
        self.ip_entry.connect("focus-out-event", self.validate_ip_address)
        self.ip_entry.connect("changed", self.validate_ip_on_change)

        # Button box
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        button_box.set_halign(Gtk.Align.CENTER)
        button_box.set_margin_top(10)
        main_box.pack_start(button_box, False, False, 0)

        # OK button
        self.ok_button = Gtk.Button(label="OK")
        self.ok_button.connect("clicked", self.on_ok_clicked)
        self.ok_button.set_sensitive(False)  # Initially disabled
        button_box.pack_start(self.ok_button, False, False, 0)

        # Cancel button
        cancel_button = Gtk.Button(label="Cancel")
        cancel_button.connect("clicked", Gtk.main_quit)
        button_box.pack_start(cancel_button, False, False, 0)

        # Create a grid for the text areas
        text_grid = Gtk.Grid()
        text_grid.set_column_spacing(10)
        text_grid.set_row_spacing(10)
        main_box.pack_start(text_grid, True, True, 0)

        # Create a fixed-width label container for consistent alignment
        label_width = 80

        # Error message label with fixed width container
        error_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        error_label_box.set_size_request(label_width, -1)
        text_grid.attach(error_label_box, 0, 0, 1, 1)

        error_label = Gtk.Label(label="Errors:")
        error_label.set_halign(Gtk.Align.START)  # Left align within the box
        error_label.set_valign(Gtk.Align.START)
        error_label_box.pack_start(error_label, False, False, 0)

        # Error message text area
        scrolled_error = Gtk.ScrolledWindow()
        scrolled_error.set_hexpand(True)
        scrolled_error.set_vexpand(True)
        scrolled_error.set_min_content_height(100)
        text_grid.attach(scrolled_error, 1, 0, 1, 1)

        self.error_text = Gtk.TextView()
        self.error_text.set_editable(False)
        self.error_text.set_wrap_mode(Gtk.WrapMode.WORD)
        self.error_buffer = self.error_text.get_buffer()
        error_tag = self.error_buffer.create_tag("error", foreground="red")
        scrolled_error.add(self.error_text)

        # Status message label with fixed width container
        message_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        message_label_box.set_size_request(label_width, -1)
        text_grid.attach(message_label_box, 0, 1, 1, 1)

        message_label = Gtk.Label(label="Messages:")
        message_label.set_halign(Gtk.Align.START)  # Left align within the box
        message_label.set_valign(Gtk.Align.START)
        message_label_box.pack_start(message_label, False, False, 0)

        # Status message text area
        scrolled_message = Gtk.ScrolledWindow()
        scrolled_message.set_hexpand(True)
        scrolled_message.set_vexpand(True)
        scrolled_message.set_min_content_height(150)
        text_grid.attach(scrolled_message, 1, 1, 1, 1)

        self.message_text = Gtk.TextView()
        self.message_text.set_editable(False)
        self.message_text.set_wrap_mode(Gtk.WrapMode.WORD)
        self.message_buffer = self.message_text.get_buffer()
        message_tag = self.message_buffer.create_tag("message", foreground="blue")
        success_tag = self.message_buffer.create_tag("success", foreground="green", weight=Pango.Weight.BOLD)
        scrolled_message.add(self.message_text)

        # Initialize password field visibility
        self.toggle_password_visibility(self.hide_password)

        # Show all widgets
        self.window.show_all()

    def disable_ui_elements(self):
        """Disable all UI elements during operations"""
        self.interface_combo.set_sensitive(False)
        self.wifi_combo.set_sensitive(False)
        self.password_entry.set_sensitive(False)
        self.ip_entry.set_sensitive(False)
        self.scan_button.set_sensitive(False)
        self.ok_button.set_sensitive(False)
        self.hide_password.set_sensitive(False)

    def enable_ui_elements(self):
        """Re-enable UI elements after operations"""
        self.interface_combo.set_sensitive(True)
        self.wifi_combo.set_sensitive(True)
        self.password_entry.set_sensitive(True)
        self.scan_button.set_sensitive(True)
        self.hide_password.set_sensitive(True)

        # IP entry is only enabled after a successful connection test
        # So don't enable it here - it will be enabled in _update_connection_status if needed

        # OK button state depends on field validation, so call check_fields
        self.check_fields()

    def on_scan_clicked(self, button):
        """Handle scan button click"""
        # Deactivate IP Address field when Scan is clicked
        self.ip_entry.set_text("")
        self.ip_entry.set_sensitive(False)
        self.connection_successful = False
        self.scan_networks()

    def on_ok_clicked(self, button):
        """Handle OK button click"""
        self.save_config()

    def wifi_changed(self, combo):
        """Handle WiFi selection change"""
        # Deactivate IP Address field when WiFi is changed
        self.ip_entry.set_text("")
        self.ip_entry.set_sensitive(False)
        self.connection_successful = False
        self.check_fields()

    def test_wifi_connection(self, widget, event=None):
        """Test connection to the selected WiFi when leaving password field"""
        active_id = self.wifi_combo.get_active()
        if active_id == -1:
            return False

        wifi_name = self.wifi_combo.get_active_text()
        password = self.password_entry.get_text()
        interface = self.interface_combo.get_active_text()

        if not wifi_name or not password:
            return False

        # Clear error messages before starting the test
        self.clear_error_messages()
        self.add_status_message(f"Testing connection to {wifi_name}...")

        # Disable UI elements during connection test
        self.disable_ui_elements()

        # Start connection test in a separate thread
        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
                        daemon=True).start()
        return True

    def _test_connection_thread(self, wifi_name, password, interface):
        """Background thread for testing WiFi connection"""
        connection_success = False
        temp_dir = "/tmp/wpa_test"
        detected_ip_range = None

        try:
            # Create a temporary control directory for wpa_supplicant
            os.makedirs(temp_dir, exist_ok=True)

            # Start a temporary wpa_supplicant instance for testing
            GLib.idle_add(lambda: self.add_status_message("Starting temporary wpa_supplicant..."))

            # Kill any existing wpa_supplicant on this interface
            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
            time.sleep(1)

            # Start wpa_supplicant in the background
            wpa_process = subprocess.Popen(
                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            time.sleep(4)  # Give it time to start

            # Add the network using wpa_cli
            GLib.idle_add(lambda: self.add_status_message("Adding network..."))
            add_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
                capture_output=True, text=True
            )
            GLib.idle_add(lambda: self.add_status_message(f'add network result:\n{add_result.stdout}'))

            # Extract the network ID from the output (last line)
            network_id = add_result.stdout.strip().split('\n')[-1]

            time.sleep(1)

            # Set the network SSID
            ssid_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
                capture_output=True, text=True
            )
            GLib.idle_add(lambda: self.add_status_message(f'ssid result:\n{ssid_result.stdout}'))

            # Set the network password
            password_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
                capture_output=True, text=True
            )
            GLib.idle_add(lambda: self.add_status_message(f'password result:\n{password_result.stdout}'))

            # Enable the network
            GLib.idle_add(lambda: self.add_status_message("Attempting to connect..."))
            status_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
                capture_output=True, text=True
            )
            GLib.idle_add(lambda: self.add_status_message(f'enable network result:\n{status_result.stdout}'))

            # Poll for connection status every 2 seconds, up to 20 seconds
            max_wait_time = 20  # seconds
            poll_interval = 2    # seconds
            elapsed_time = 0

            while elapsed_time < max_wait_time:
                # Check connection status
                status_result = subprocess.run(
                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
                    capture_output=True, text=True
                )

                # Check if we're connected
                if "wpa_state=COMPLETED" in status_result.stdout:
                    connection_success = True
                    GLib.idle_add(lambda: self.add_status_message("WiFi credentials are valid!"))

                    # Try to get an IP address via DHCP to determine the network's IP range
                    GLib.idle_add(lambda: self.add_status_message("Requesting temporary IP to detect network range..."))

                    # Run dhclient to get an IP address
                    dhcp_result = subprocess.run(
                        ["sudo", "dhclient", "-1", interface],
                        capture_output=True, text=True
                    )

                    # Check the assigned IP address
                    ip_result = subprocess.run(
                        ["ip", "addr", "show", interface],
                        capture_output=True, text=True
                    )

                    # Extract IP address using regex
                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
                    if ip_match:
                        assigned_ip = ip_match.group(1)
                        # Extract the network prefix (e.g., 192.168.1)
                        ip_parts = assigned_ip.split('.')
                        if len(ip_parts) == 4:
                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
                            GLib.idle_add(lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))

                            # Update the IP address suggestion with preferred segment
                            if detected_ip_range:
                                GLib.idle_add(lambda range=detected_ip_range: self.update_ip_suggestion(range))
                    break

                # Wait before checking again
                time.sleep(poll_interval)
                elapsed_time += poll_interval
                GLib.idle_add(lambda et=elapsed_time, mt=max_wait_time: self.add_status_message(f"Waiting for connection... ({et}/{mt}s)"))

            if not connection_success:
                GLib.idle_add(lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))

        except Exception as e:
            error_msg = f"WiFi connection test failed: {str(e)}"
            GLib.idle_add(lambda: self.add_error_message(error_msg))

        finally:
            # Release the DHCP lease if we requested one
            if connection_success:
                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)

            # Clean up - terminate wpa_supplicant
            GLib.idle_add(lambda: self.add_status_message("Cleaning up test connection..."))
            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)

            # Remove temporary directory
            try:
                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
            except:
                pass

            # Re-enable UI elements
            GLib.idle_add(lambda: self.enable_ui_elements())

            # Update connection status and check if OK button should be enabled
            GLib.idle_add(lambda: self._update_connection_status(connection_success, detected_ip_range))

    def update_ip_suggestion(self, ip_range):
        """Update the IP address field with a suggestion based on the detected network range"""
        suggested_ip = f"{ip_range}.{self.preferred_ip_segment}"  # Use preferred segment
        self.ip_entry.set_text(suggested_ip)
        self.validate_ip_on_change(self.ip_entry)  # Validate the new IP

    def _update_connection_status(self, connection_success, detected_ip_range=None):
        """Update the connection status and check if OK button should be enabled"""
        self.connection_successful = connection_success

        # Enable and fill IP field only if connection was successful
        if connection_success:
            self.ip_entry.set_sensitive(True)
            if detected_ip_range and not self.ip_entry.get_text():
                self.update_ip_suggestion(detected_ip_range)
        else:
            # If connection failed, disable IP field and clear it
            self.ip_entry.set_sensitive(False)
            self.ip_entry.set_text("")

        self.check_fields()

    def validate_ip_on_change(self, widget, *args):
        """Validate IP address whenever it changes (but don't show errors)"""
        ip = self.ip_entry.get_text()

        # Check if IP is valid
        try:
            # Try to create an IPv4Address object to validate
            ipaddress.IPv4Address(ip)
            self.ip_valid = True
        except ValueError:
            # If not a valid IP, check if it's a partial IP (like "192.168.")
            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
                # It's a partial IP, which is fine while typing
                self.ip_valid = False
            else:
                # Invalid IP format, but don't show error yet
                self.ip_valid = False

        # Update OK button state
        self.check_fields()

    def validate_ip_address(self, widget, event=None):
        """Validate the IP address when focus leaves the field"""
        ip = self.ip_entry.get_text()

        # Clear any previous IP-related error messages
        self.clear_specific_error_messages("IP address")

        # Check if IP is valid
        try:
            # Try to create an IPv4Address object to validate
            ipaddress.IPv4Address(ip)
            self.ip_valid = True
            self.check_fields()
            return True
        except ValueError:
            # If not a valid IP, check if it's a partial IP (like "192.168.")
            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
                # It's a partial IP, which is fine while typing
                self.ip_valid = False
                self.check_fields()
                return False
            else:
                # Invalid IP format - show error message now that focus has left
                error_msg = f"Invalid IP address format: {ip}"
                self.add_error_message(error_msg)
                self.ip_valid = False
                self.check_fields()
                return False

    def clear_specific_error_messages(self, keyword):
        """Clear error messages containing a specific keyword"""
        text = self.error_buffer.get_text(
            self.error_buffer.get_start_iter(),
            self.error_buffer.get_end_iter(),
            True
        )

        # Filter out lines containing the keyword
        lines = text.split('\n')
        filtered_lines = [line for line in lines if keyword not in line]

        # Clear and reinsert filtered content
        self.error_buffer.set_text('\n'.join(filtered_lines))

    def add_error_message(self, message):
        """Add an error message to the error text area"""
        end_iter = self.error_buffer.get_end_iter()
        self.error_buffer.insert_with_tags_by_name(end_iter, message + "\n", "error")

        # Scroll to the end
        mark = self.error_buffer.create_mark("end", self.error_buffer.get_end_iter(), False)
        self.error_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def clear_error_messages(self):
        """Clear all error messages"""
        self.error_buffer.set_text("")

    def add_status_message(self, message):
        """Add a status message to the message text area"""
        end_iter = self.message_buffer.get_end_iter()
        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "message")

        # Scroll to the end
        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def add_success_message(self, message):
        """Add a success message to the message text area with green bold text"""
        end_iter = self.message_buffer.get_end_iter()
        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "success")

        # Scroll to the end
        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def clear_status_messages(self):
        """Clear all status messages"""
        self.message_buffer.set_text("")

    def interface_changed(self, combo):
        """Handle interface selection change"""
        # Clear the Wi-Fi dropdown
        self.wifi_combo.remove_all()
        self.wifi_list = []

        # Deactivate IP Address field when interface is changed
        self.ip_entry.set_text("")
        self.ip_entry.set_sensitive(False)
        self.connection_successful = False

        # Clear error and message boxes
        self.clear_error_messages()
        self.clear_status_messages()

        # Disable UI elements during scan
        self.disable_ui_elements()

        # Start scanning with the new interface
        self.scan_networks()

    def find_interfaces(self):
        """Find available network interfaces"""
        status_msg = "Finding network interfaces..."
        self.add_status_message(status_msg)

        # Disable UI elements during interface detection
        self.disable_ui_elements()

        # Start in a separate thread to avoid freezing the UI
        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()

    def _find_interfaces_thread(self):
        """Background thread for finding interfaces"""
        try:
            # Get list of wireless interfaces
            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
            all_interfaces = output.strip().split()

            # Filter for wireless interfaces (typically wlan*)
            self.interfaces = [iface for iface in all_interfaces if
                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
                              iface.startswith("wlan")]

            # Update the dropdown on the main thread
            GLib.idle_add(self._update_interface_dropdown)

        except Exception as e:
            error_msg = f"Interface detection error: {str(e)}"
            # Update error message on the main thread
            GLib.idle_add(lambda: self.add_error_message(error_msg))
            GLib.idle_add(lambda: self.enable_ui_elements())

    def _update_interface_dropdown(self):
        """Update the interface dropdown with found interfaces"""
        if not self.interfaces:
            # If no wireless interfaces found, add a default one
            self.interfaces = ["wlan0"]
            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")

        # Clear and populate the interface dropdown
        self.interface_combo.remove_all()
        for iface in self.interfaces:
            self.interface_combo.append_text(iface)

        # Try to select wlan0 by default, or the first available interface
        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
        index = self.interfaces.index(default_interface)
        self.interface_combo.set_active(index)

        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
        self.add_status_message(status_msg)

        # Start scanning with the selected interface
        self.scan_networks()

    def scan_networks(self):
        """Scan for available Wi-Fi networks using selected interface"""
        interface = self.interface_combo.get_active_text()
        if not interface:
            return

        # Clear error and message boxes
        self.clear_error_messages()
        self.clear_status_messages()

        status_msg = f"Scanning for networks on {interface}..."
        self.add_status_message(status_msg)

        # Disable UI elements during scan
        self.disable_ui_elements()

        # Start scanning in a separate thread to avoid freezing the UI
        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()

    def _scan_thread(self, interface):
        """Background thread for network scanning"""
        try:
            # First bring up the interface to ensure it's active
            GLib.idle_add(lambda: self.add_status_message(f"Bringing up interface {interface}..."))
            ifconfig_result=subprocess.run(["sudo", "ifconfig", interface, "up"], capture_output=True, text=True, check=True)
            time.sleep(4)  # Give it time to initialize

            # Run iwlist scan on the selected interface
            GLib.idle_add(lambda: self.add_status_message(f"Scanning for networks..."))
            iwlist_result = subprocess.check_output(["sudo", "iwlist", interface, "scan"], universal_newlines=True)

            # Extract networks and their signal levels
            networks_with_signal = []

            # Split the iwlist_result by "Cell" to process each network separately
            cells = iwlist_result.split("Cell ")

            for cell in cells[1:]:  # Skip the first element (header)
                essid_match = re.search(r'ESSID:"(.*?)"', cell)
                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)

                if essid_match and signal_match:
                    essid = essid_match.group(1)

                    # Skip empty or null-filled SSIDs
                    if not essid or '\\x00' in essid:
                        continue

                    signal_level = int(signal_match.group(1))
                    networks_with_signal.append((essid, signal_level))

            # Sort networks by signal strength (highest first)
            networks_with_signal.sort(key=lambda x: x[1], reverse=True)

            # Extract just the network names, keeping the sorted order
            self.wifi_list = [network[0] for network in networks_with_signal]

            # Update the dropdown on the main thread
            GLib.idle_add(self._update_dropdown)

        except subprocess.CalledProcessError as e:
            error_msg = f"Scan error: {e.stderr if hasattr(e, 'stderr') else str(e)}"
            # Update error message on the main thread
            GLib.idle_add(lambda: self.add_error_message(error_msg))
            GLib.idle_add(lambda: self.enable_ui_elements())
        except Exception as e:
            error_msg = f"Scan error: {str(e)}"
            # Update error message on the main thread
            GLib.idle_add(lambda: self.add_error_message(error_msg))
            GLib.idle_add(lambda: self.enable_ui_elements())

    def _update_dropdown(self):
        """Update the dropdown with found networks"""
        # Clear and populate the wifi dropdown
        self.wifi_combo.remove_all()
        for network in self.wifi_list:
            self.wifi_combo.append_text(network)

        if self.wifi_list:
            self.wifi_combo.set_active(0)  # Select the first (strongest) network
            status_msg = f"Found {len(self.wifi_list)} networks"
            self.add_status_message(status_msg)
        else:
            error_msg = "No networks found"
            self.add_error_message(error_msg)

        # Re-enable UI elements
        self.enable_ui_elements()

    def toggle_password_visibility(self, button):
        """Toggle password visibility based on checkbox state"""
        if button.get_active():
            self.password_entry.set_visibility(False)  # Hide password
        else:
            self.password_entry.set_visibility(True)   # Show password

    def check_fields(self):
        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
        wifi_selected = self.wifi_combo.get_active() != -1
        password_text = self.password_entry.get_text()
        ip_text = self.ip_entry.get_text()

        if (wifi_selected and
            password_text and
            ip_text and
            self.ip_valid and
            self.connection_successful):
            self.ok_button.set_sensitive(True)
        else:
            self.ok_button.set_sensitive(False)

    def save_config(self):
        """Save the Wi-Fi configuration to the specified file"""
        wifi_name = self.wifi_combo.get_active_text()
        password = self.password_entry.get_text()
        ip_address = self.ip_entry.get_text()
        interface = self.interface_combo.get_active_text()

        # Temporarily disable the OK button during processing
        self.disable_ui_elements()

        success = True
        wifi_success = False
        interface_success = False
        network_restart_success = False

        try:
            # Read the template wifi_file
            with open(self.temp_wifi_path, 'r') as file:
                wifi_content = file.read()

            # Replace placeholders with user input
            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
            wifi_content = wifi_content.replace("<password>", password)

            # Create a temporary file with the content
            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
            with open(temp_wifi_file, 'w') as file:
                file.write(wifi_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_wifi_file, self.wifi_path],
                capture_output=True, text=True
            )

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_wifi_file)

            wifi_success = True
            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
            self.add_status_message(status_msg)
            # Clear error messages on success
            self.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
            self.add_error_message(error_msg)
            success = False

        try:
            # Read and update the interface template
            with open(self.temp_interface_path, 'r') as file:
                interface_content = file.read()

            # Replace IP address placeholder with user input
            interface_content = interface_content.replace("<address>", ip_address)

            # Create a temporary file with the content
            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
            with open(temp_interface_file, 'w') as file:
                file.write(interface_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_interface_file, self.interface_path],
                capture_output=True, text=True
            )

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_interface_file)

            interface_success = True
            status_msg = f"Network interface configuration saved to {self.interface_path}"
            self.add_status_message(status_msg)
            # Clear error messages on success
            if not wifi_success:  # Only clear if not already cleared
                self.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save interface configuration: {str(e)}"
            self.add_error_message(error_msg)
            success = False

        # If both configurations were successful, restart the network interface
        if wifi_success and interface_success:
            try:
                self.add_status_message(f"Bringing down interface {interface}...")
                # First bring down the interface
                result = subprocess.run(
                    ["sudo", "ifdown", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")

                self.add_status_message(f"Bringing up interface {interface}...")
                # Then bring it back up with the new configuration
                result = subprocess.run(
                    ["sudo", "ifup", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    raise Exception(f"ifup command failed: {result.stderr}")

                network_restart_success = True
                self.add_status_message(f"Successfully restarted interface {interface}")
                # Clear error messages on success
                self.clear_error_messages()

            except Exception as e:
                error_msg = f"Failed to restart network interface: {str(e)}"
                self.add_error_message(error_msg)
                success = False

        # Final status message
        if success and network_restart_success:
            self.add_success_message("Configuration completed and network restarted successfully!")
        elif success:
            self.add_error_message("Configuration completed successfully, but network restart failed.")
        else:
            if wifi_success:
                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
            elif interface_success:
                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
            else:
                self.add_error_message("Configuration failed completely.")

        # Re-enable the UI elements
        self.enable_ui_elements()

if __name__ == "__main__":
    app = WifiConfigApp()
    Gtk.main()










##!/usr/bin/env python3
#import gi
#gi.require_version('Gtk', '3.0')
#from gi.repository import Gtk, GLib, Pango
#import os
#import shutil
#import subprocess
#import re
#import threading
#import ipaddress
#import time
#
#class WifiConfigApp:
#    def __init__(self):
#        # Set preferred lowest segment of IP address
#        self.preferred_ip_segment = "200"
#
#        # Get the directory where the script is located
#        script_dir = os.path.dirname(os.path.abspath(__file__))
#
#        # Define paths relative to the script location
#        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
#        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')
#
#        self.interface_path = '/etc/network/interfaces'
#        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'
#
#        # Lists to store interfaces and Wi-Fi networks
#        self.interfaces = []
#        self.wifi_list = []
#
#        # Add a flag to track connection success
#        self.connection_successful = False
#
#        # Flag to track if IP is valid
#        self.ip_valid = False
#
#        # Build the UI
#        self.build_ui()
#
#        # Find available interfaces and start scanning
#        self.find_interfaces()
#
#    def build_ui(self):
#        # Create main window
#        self.window = Gtk.Window(title="Raspberry Pi Wi-Fi Configuration")
#        self.window.set_default_size(780, 540)
#        self.window.connect("destroy", Gtk.main_quit)
#
#        # Create main container
#        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
#        main_box.set_margin_start(20)
#        main_box.set_margin_end(20)
#        main_box.set_margin_top(20)
#        main_box.set_margin_bottom(20)
#        self.window.add(main_box)
#
#        # Create form grid
#        form_grid = Gtk.Grid()
#        form_grid.set_column_spacing(10)
#        form_grid.set_row_spacing(10)
#        main_box.pack_start(form_grid, False, False, 0)
#
#        # Interface selection
#        interface_label = Gtk.Label(label="Interface:")
#        interface_label.set_halign(Gtk.Align.START)
#        form_grid.attach(interface_label, 0, 0, 1, 1)
#
#        self.interface_combo = Gtk.ComboBoxText()
#        form_grid.attach(self.interface_combo, 1, 0, 1, 1)
#        self.interface_combo.connect("changed", self.interface_changed)
#
#        # Wi-Fi name selection
#        wifi_label = Gtk.Label(label="Wi-Fi Name:")
#        wifi_label.set_halign(Gtk.Align.START)
#        form_grid.attach(wifi_label, 0, 1, 1, 1)
#
#        self.wifi_combo = Gtk.ComboBoxText()
#        form_grid.attach(self.wifi_combo, 1, 1, 1, 1)
#
#        # Scan button
#        self.scan_button = Gtk.Button(label="Scan")
#        self.scan_button.connect("clicked", self.on_scan_clicked)
#        form_grid.attach(self.scan_button, 2, 1, 1, 1)
#
#        # Password field
#        password_label = Gtk.Label(label="Password:")
#        password_label.set_halign(Gtk.Align.START)
#        form_grid.attach(password_label, 0, 2, 1, 1)
#
#        self.password_entry = Gtk.Entry()
#        self.password_entry.set_width_chars(30)
#        form_grid.attach(self.password_entry, 1, 2, 1, 1)
#        self.password_entry.connect("focus-out-event", self.test_wifi_connection)
#
#        # Hide password checkbox
#        self.hide_password = Gtk.CheckButton(label="Hide")
#        self.hide_password.connect("toggled", self.toggle_password_visibility)
#        form_grid.attach(self.hide_password, 2, 2, 1, 1)
#
#        # IP Address field
#        ip_label = Gtk.Label(label="IP Address:")
#        ip_label.set_halign(Gtk.Align.START)
#        form_grid.attach(ip_label, 0, 3, 1, 1)
#
#        self.ip_entry = Gtk.Entry()
#        self.ip_entry.set_width_chars(30)
#        self.ip_entry.set_text(f"192.168.1.{self.preferred_ip_segment}")
#        form_grid.attach(self.ip_entry, 1, 3, 1, 1)
#        self.ip_entry.connect("focus-out-event", self.validate_ip_address)
#        self.ip_entry.connect("changed", self.validate_ip_on_change)
#
#        # Button box
#        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
#        button_box.set_halign(Gtk.Align.CENTER)
#        button_box.set_margin_top(10)
#        main_box.pack_start(button_box, False, False, 0)
#
#        # OK button
#        self.ok_button = Gtk.Button(label="OK")
#        self.ok_button.connect("clicked", self.on_ok_clicked)
#        self.ok_button.set_sensitive(False)  # Initially disabled
#        button_box.pack_start(self.ok_button, False, False, 0)
#
#        # Cancel button
#        cancel_button = Gtk.Button(label="Cancel")
#        cancel_button.connect("clicked", Gtk.main_quit)
#        button_box.pack_start(cancel_button, False, False, 0)
#
#        # Create a grid for the text areas
#        text_grid = Gtk.Grid()
#        text_grid.set_column_spacing(10)
#        text_grid.set_row_spacing(10)
#        main_box.pack_start(text_grid, True, True, 0)
#
#        # Create a fixed-width label container for consistent alignment
#        label_width = 80
#
#        # Error message label with fixed width container
#        error_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
#        error_label_box.set_size_request(label_width, -1)
#        text_grid.attach(error_label_box, 0, 0, 1, 1)
#
#        error_label = Gtk.Label(label="Errors:")
#        error_label.set_halign(Gtk.Align.START)  # Left align within the box
#        error_label.set_valign(Gtk.Align.START)
#        error_label_box.pack_start(error_label, False, False, 0)
#
#        # Error message text area
#        scrolled_error = Gtk.ScrolledWindow()
#        scrolled_error.set_hexpand(True)
#        scrolled_error.set_vexpand(True)
#        scrolled_error.set_min_content_height(100)
#        text_grid.attach(scrolled_error, 1, 0, 1, 1)
#
#        self.error_text = Gtk.TextView()
#        self.error_text.set_editable(False)
#        self.error_text.set_wrap_mode(Gtk.WrapMode.WORD)
#        self.error_buffer = self.error_text.get_buffer()
#        error_tag = self.error_buffer.create_tag("error", foreground="red")
#        scrolled_error.add(self.error_text)
#
#        # Status message label with fixed width container
#        message_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
#        message_label_box.set_size_request(label_width, -1)
#        text_grid.attach(message_label_box, 0, 1, 1, 1)
#
#        message_label = Gtk.Label(label="Messages:")
#        message_label.set_halign(Gtk.Align.START)  # Left align within the box
#        message_label.set_valign(Gtk.Align.START)
#        message_label_box.pack_start(message_label, False, False, 0)
#
#        # Status message text area
#        scrolled_message = Gtk.ScrolledWindow()
#        scrolled_message.set_hexpand(True)
#        scrolled_message.set_vexpand(True)
#        scrolled_message.set_min_content_height(150)
#        text_grid.attach(scrolled_message, 1, 1, 1, 1)
#
#        self.message_text = Gtk.TextView()
#        self.message_text.set_editable(False)
#        self.message_text.set_wrap_mode(Gtk.WrapMode.WORD)
#        self.message_buffer = self.message_text.get_buffer()
#        message_tag = self.message_buffer.create_tag("message", foreground="blue")
#        success_tag = self.message_buffer.create_tag("success", foreground="green", weight=Pango.Weight.BOLD)
#        scrolled_message.add(self.message_text)
#
#        # Initialize password field visibility
#        self.toggle_password_visibility(self.hide_password)
#
#        # Show all widgets
#        self.window.show_all()
#
#    def disable_ui_elements(self):
#        """Disable all UI elements during operations"""
#        self.interface_combo.set_sensitive(False)
#        self.wifi_combo.set_sensitive(False)
#        self.password_entry.set_sensitive(False)
#        self.ip_entry.set_sensitive(False)
#        self.scan_button.set_sensitive(False)
#        self.ok_button.set_sensitive(False)
#        self.hide_password.set_sensitive(False)
#
#    def enable_ui_elements(self):
#        """Re-enable UI elements after operations"""
#        self.interface_combo.set_sensitive(True)
#        self.wifi_combo.set_sensitive(True)
#        self.password_entry.set_sensitive(True)
#        self.ip_entry.set_sensitive(True)
#        self.scan_button.set_sensitive(True)
#        self.hide_password.set_sensitive(True)
#        # OK button state depends on field validation, so call check_fields
#        self.check_fields()
#
#    def on_scan_clicked(self, button):
#        """Handle scan button click"""
#        self.scan_networks()
#
#    def on_ok_clicked(self, button):
#        """Handle OK button click"""
#        self.save_config()
#
#    def test_wifi_connection(self, widget, event=None):
#        """Test connection to the selected WiFi when leaving password field"""
#        active_id = self.wifi_combo.get_active()
#        if active_id == -1:
#            return False
#
#        wifi_name = self.wifi_combo.get_active_text()
#        password = self.password_entry.get_text()
#        interface = self.interface_combo.get_active_text()
#
#        if not wifi_name or not password:
#            return False
#
#        # Clear error messages before starting the test
#        self.clear_error_messages()
#        self.add_status_message(f"Testing connection to {wifi_name}...")
#
#        # Disable UI elements during connection test
#        self.disable_ui_elements()
#
#        # Start connection test in a separate thread
#        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
#                        daemon=True).start()
#        return True
#
#    def _test_connection_thread(self, wifi_name, password, interface):
#        """Background thread for testing WiFi connection"""
#        connection_success = False
#        temp_dir = "/tmp/wpa_test"
#        detected_ip_range = None
#
#        try:
#            # Create a temporary control directory for wpa_supplicant
#            os.makedirs(temp_dir, exist_ok=True)
#
#            # Start a temporary wpa_supplicant instance for testing
#            GLib.idle_add(lambda: self.add_status_message("Starting temporary wpa_supplicant..."))
#
#            # Kill any existing wpa_supplicant on this interface
#            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
#            time.sleep(1)
#
#            # Start wpa_supplicant in the background
#            wpa_process = subprocess.Popen(
#                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
#                stdout=subprocess.PIPE, stderr=subprocess.PIPE
#            )
#            time.sleep(4)  # Give it time to start
#
#            # Add the network using wpa_cli
#            GLib.idle_add(lambda: self.add_status_message("Adding network..."))
#            add_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
#                capture_output=True, text=True
#            )
#            GLib.idle_add(lambda: self.add_status_message(f'add network result:\n{add_result.stdout}'))
#
#            # Extract the network ID from the output (last line)
#            network_id = add_result.stdout.strip().split('\n')[-1]
#
#            time.sleep(1)
#
#            # Set the network SSID
#            ssid_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
#                capture_output=True, text=True
#            )
#            GLib.idle_add(lambda: self.add_status_message(f'ssid result:\n{ssid_result.stdout}'))
#
#            # Set the network password
#            password_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
#                capture_output=True, text=True
#            )
#            GLib.idle_add(lambda: self.add_status_message(f'password result:\n{password_result.stdout}'))
#
#            # Enable the network
#            GLib.idle_add(lambda: self.add_status_message("Attempting to connect..."))
#            status_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
#                capture_output=True, text=True
#            )
#            GLib.idle_add(lambda: self.add_status_message(f'enable network result:\n{status_result.stdout}'))
#
#            # Poll for connection status every 2 seconds, up to 20 seconds
#            max_wait_time = 20  # seconds
#            poll_interval = 2    # seconds
#            elapsed_time = 0
#
#            while elapsed_time < max_wait_time:
#                # Check connection status
#                status_result = subprocess.run(
#                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
#                    capture_output=True, text=True
#                )
#
#                # Check if we're connected
#                if "wpa_state=COMPLETED" in status_result.stdout:
#                    connection_success = True
#                    GLib.idle_add(lambda: self.add_status_message("WiFi credentials are valid!"))
#
#                    # Try to get an IP address via DHCP to determine the network's IP range
#                    GLib.idle_add(lambda: self.add_status_message("Requesting temporary IP to detect network range..."))
#
#                    # Run dhclient to get an IP address
#                    dhcp_result = subprocess.run(
#                        ["sudo", "dhclient", "-1", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Check the assigned IP address
#                    ip_result = subprocess.run(
#                        ["ip", "addr", "show", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Extract IP address using regex
#                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
#                    if ip_match:
#                        assigned_ip = ip_match.group(1)
#                        # Extract the network prefix (e.g., 192.168.1)
#                        ip_parts = assigned_ip.split('.')
#                        if len(ip_parts) == 4:
#                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
#                            GLib.idle_add(lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))
#
#                            # Update the IP address suggestion with preferred segment
#                            if detected_ip_range:
#                                GLib.idle_add(lambda range=detected_ip_range: self.update_ip_suggestion(range))
#                    break
#
#                # Wait before checking again
#                time.sleep(poll_interval)
#                elapsed_time += poll_interval
#                GLib.idle_add(lambda et=elapsed_time, mt=max_wait_time: self.add_status_message(f"Waiting for connection... ({et}/{mt}s)"))
#
#            if not connection_success:
#                GLib.idle_add(lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))
#
#        except Exception as e:
#            error_msg = f"WiFi connection test failed: {str(e)}"
#            GLib.idle_add(lambda: self.add_error_message(error_msg))
#
#        finally:
#            # Release the DHCP lease if we requested one
#            if connection_success:
#                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)
#
#            # Clean up - terminate wpa_supplicant
#            GLib.idle_add(lambda: self.add_status_message("Cleaning up test connection..."))
#            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)
#
#            # Remove temporary directory
#            try:
#                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
#            except:
#                pass
#
#            # Re-enable UI elements
#            GLib.idle_add(lambda: self.enable_ui_elements())
#
#            # Update connection status and check if OK button should be enabled
#            GLib.idle_add(lambda: self._update_connection_status(connection_success))
#
#    def update_ip_suggestion(self, ip_range):
#        """Update the IP address field with a suggestion based on the detected network range"""
#        suggested_ip = f"{ip_range}.{self.preferred_ip_segment}"  # Use preferred segment
#        self.ip_entry.set_text(suggested_ip)
#        self.validate_ip_on_change(self.ip_entry)  # Validate the new IP
#
#    def _update_connection_status(self, connection_success):
#        """Update the connection status and check if OK button should be enabled"""
#        self.connection_successful = connection_success
#        self.check_fields()
#
#    def validate_ip_on_change(self, widget, *args):
#        """Validate IP address whenever it changes (but don't show errors)"""
#        ip = self.ip_entry.get_text()
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#            else:
#                # Invalid IP format, but don't show error yet
#                self.ip_valid = False
#
#        # Update OK button state
#        self.check_fields()
#
#    def validate_ip_address(self, widget, event=None):
#        """Validate the IP address when focus leaves the field"""
#        ip = self.ip_entry.get_text()
#
#        # Clear any previous IP-related error messages
#        self.clear_specific_error_messages("IP address")
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#            self.check_fields()
#            return True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#                self.check_fields()
#                return False
#            else:
#                # Invalid IP format - show error message now that focus has left
#                error_msg = f"Invalid IP address format: {ip}"
#                self.add_error_message(error_msg)
#                self.ip_valid = False
#                self.check_fields()
#                return False
#
#    def clear_specific_error_messages(self, keyword):
#        """Clear error messages containing a specific keyword"""
#        text = self.error_buffer.get_text(
#            self.error_buffer.get_start_iter(),
#            self.error_buffer.get_end_iter(),
#            True
#        )
#
#        # Filter out lines containing the keyword
#        lines = text.split('\n')
#        filtered_lines = [line for line in lines if keyword not in line]
#
#        # Clear and reinsert filtered content
#        self.error_buffer.set_text('\n'.join(filtered_lines))
#
#    def add_error_message(self, message):
#        """Add an error message to the error text area"""
#        end_iter = self.error_buffer.get_end_iter()
#        self.error_buffer.insert_with_tags_by_name(end_iter, message + "\n", "error")
#
#        # Scroll to the end
#        mark = self.error_buffer.create_mark("end", self.error_buffer.get_end_iter(), False)
#        self.error_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)
#
#    def clear_error_messages(self):
#        """Clear all error messages"""
#        self.error_buffer.set_text("")
#
#    def add_status_message(self, message):
#        """Add a status message to the message text area"""
#        end_iter = self.message_buffer.get_end_iter()
#        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "message")
#
#        # Scroll to the end
#        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
#        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)
#
#    def add_success_message(self, message):
#        """Add a success message to the message text area with green bold text"""
#        end_iter = self.message_buffer.get_end_iter()
#        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "success")
#
#        # Scroll to the end
#        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
#        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)
#
#    def clear_status_messages(self):
#        """Clear all status messages"""
#        self.message_buffer.set_text("")
#
#    def interface_changed(self, combo):
#        """Handle interface selection change"""
#        # Clear the Wi-Fi dropdown
#        self.wifi_combo.remove_all()
#        self.wifi_list = []
#
#        # Clear error and message boxes
#        self.clear_error_messages()
#        self.clear_status_messages()
#
#        # Disable UI elements during scan
#        self.disable_ui_elements()
#
#        # Start scanning with the new interface
#        self.scan_networks()
#
#    def find_interfaces(self):
#        """Find available network interfaces"""
#        status_msg = "Finding network interfaces..."
#        self.add_status_message(status_msg)
#
#        # Disable UI elements during interface detection
#        self.disable_ui_elements()
#
#        # Start in a separate thread to avoid freezing the UI
#        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()
#
#    def _find_interfaces_thread(self):
#        """Background thread for finding interfaces"""
#        try:
#            # Get list of wireless interfaces
#            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
#            all_interfaces = output.strip().split()
#
#            # Filter for wireless interfaces (typically wlan*)
#            self.interfaces = [iface for iface in all_interfaces if
#                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
#                              iface.startswith("wlan")]
#
#            # Update the dropdown on the main thread
#            GLib.idle_add(self._update_interface_dropdown)
#
#        except Exception as e:
#            error_msg = f"Interface detection error: {str(e)}"
#            # Update error message on the main thread
#            GLib.idle_add(lambda: self.add_error_message(error_msg))
#            GLib.idle_add(lambda: self.enable_ui_elements())
#
#    def _update_interface_dropdown(self):
#        """Update the interface dropdown with found interfaces"""
#        if not self.interfaces:
#            # If no wireless interfaces found, add a default one
#            self.interfaces = ["wlan0"]
#            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")
#
#        # Clear and populate the interface dropdown
#        self.interface_combo.remove_all()
#        for iface in self.interfaces:
#            self.interface_combo.append_text(iface)
#
#        # Try to select wlan0 by default, or the first available interface
#        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
#        index = self.interfaces.index(default_interface)
#        self.interface_combo.set_active(index)
#
#        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
#        self.add_status_message(status_msg)
#
#        # Start scanning with the selected interface
#        self.scan_networks()
#
#    def scan_networks(self):
#        """Scan for available Wi-Fi networks using selected interface"""
#        interface = self.interface_combo.get_active_text()
#        if not interface:
#            return
#
#        # Clear error and message boxes
#        self.clear_error_messages()
#        self.clear_status_messages()
#
#        status_msg = f"Scanning for networks on {interface}..."
#        self.add_status_message(status_msg)
#
#        # Disable UI elements during scan
#        self.disable_ui_elements()
#
#        # Start scanning in a separate thread to avoid freezing the UI
#        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()
#
#    def _scan_thread(self, interface):
#        """Background thread for network scanning"""
#        try:
#            # First bring up the interface to ensure it's active
#            GLib.idle_add(lambda: self.add_status_message(f"Bringing up interface {interface}..."))
#            ifconfig_result=subprocess.run(["sudo", "ifconfig", interface, "up"], capture_output=True, text=True, check=True)
#            time.sleep(4)  # Give it time to initialize
#
#            # Run iwlist scan on the selected interface
#            GLib.idle_add(lambda: self.add_status_message(f"Scanning for networks..."))
#            iwlist_result = subprocess.check_output(["sudo", "iwlist", interface, "scan"], universal_newlines=True)
#
#            # Extract networks and their signal levels
#            networks_with_signal = []
#
#            # Split the iwlist_result by "Cell" to process each network separately
#            cells = iwlist_result.split("Cell ")
#
#            for cell in cells[1:]:  # Skip the first element (header)
#                essid_match = re.search(r'ESSID:"(.*?)"', cell)
#                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
#
#                if essid_match and signal_match:
#                    essid = essid_match.group(1)
#
#                    # Skip empty or null-filled SSIDs
#                    if not essid or '\\x00' in essid:
#                        continue
#
#                    signal_level = int(signal_match.group(1))
#                    networks_with_signal.append((essid, signal_level))
#
#            # Sort networks by signal strength (highest first)
#            networks_with_signal.sort(key=lambda x: x[1], reverse=True)
#
#            # Extract just the network names, keeping the sorted order
#            self.wifi_list = [network[0] for network in networks_with_signal]
#
#            # Update the dropdown on the main thread
#            GLib.idle_add(self._update_dropdown)
#
#        except subprocess.CalledProcessError as e:
#            error_msg = f"Scan error: {e.stderr if hasattr(e, 'stderr') else str(e)}"
#            # Update error message on the main thread
#            GLib.idle_add(lambda: self.add_error_message(error_msg))
#            GLib.idle_add(lambda: self.enable_ui_elements())
#        except Exception as e:
#            error_msg = f"Scan error: {str(e)}"
#            # Update error message on the main thread
#            GLib.idle_add(lambda: self.add_error_message(error_msg))
#            GLib.idle_add(lambda: self.enable_ui_elements())
#
#    def _update_dropdown(self):
#        """Update the dropdown with found networks"""
#        # Clear and populate the wifi dropdown
#        self.wifi_combo.remove_all()
#        for network in self.wifi_list:
#            self.wifi_combo.append_text(network)
#
#        if self.wifi_list:
#            self.wifi_combo.set_active(0)  # Select the first (strongest) network
#            status_msg = f"Found {len(self.wifi_list)} networks"
#            self.add_status_message(status_msg)
#        else:
#            error_msg = "No networks found"
#            self.add_error_message(error_msg)
#
#        # Re-enable UI elements
#        self.enable_ui_elements()
#
#    def toggle_password_visibility(self, button):
#        """Toggle password visibility based on checkbox state"""
#        if button.get_active():
#            self.password_entry.set_visibility(False)  # Hide password
#        else:
#            self.password_entry.set_visibility(True)   # Show password
#
#    def check_fields(self):
#        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
#        wifi_selected = self.wifi_combo.get_active() != -1
#        password_text = self.password_entry.get_text()
#        ip_text = self.ip_entry.get_text()
#
#        if (wifi_selected and
#            password_text and
#            ip_text and
#            self.ip_valid and
#            self.connection_successful):
#            self.ok_button.set_sensitive(True)
#        else:
#            self.ok_button.set_sensitive(False)
#
#    def save_config(self):
#        """Save the Wi-Fi configuration to the specified file"""
#        wifi_name = self.wifi_combo.get_active_text()
#        password = self.password_entry.get_text()
#        ip_address = self.ip_entry.get_text()
#        interface = self.interface_combo.get_active_text()
#
#        # Temporarily disable the OK button during processing
#        self.disable_ui_elements()
#
#        success = True
#        wifi_success = False
#        interface_success = False
#        network_restart_success = False
#
#        try:
#            # Read the template wifi_file
#            with open(self.temp_wifi_path, 'r') as file:
#                wifi_content = file.read()
#
#            # Replace placeholders with user input
#            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
#            wifi_content = wifi_content.replace("<password>", password)
#
#            # Create a temporary file with the content
#            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
#            with open(temp_wifi_file, 'w') as file:
#                file.write(wifi_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_wifi_file, self.wifi_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_wifi_file)
#
#            wifi_success = True
#            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        try:
#            # Read and update the interface template
#            with open(self.temp_interface_path, 'r') as file:
#                interface_content = file.read()
#
#            # Replace IP address placeholder with user input
#            interface_content = interface_content.replace("<address>", ip_address)
#
#            # Create a temporary file with the content
#            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
#            with open(temp_interface_file, 'w') as file:
#                file.write(interface_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_interface_file, self.interface_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_interface_file)
#
#            interface_success = True
#            status_msg = f"Network interface configuration saved to {self.interface_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            if not wifi_success:  # Only clear if not already cleared
#                self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save interface configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        # If both configurations were successful, restart the network interface
#        if wifi_success and interface_success:
#            try:
#                self.add_status_message(f"Bringing down interface {interface}...")
#                # First bring down the interface
#                result = subprocess.run(
#                    ["sudo", "ifdown", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")
#
#                self.add_status_message(f"Bringing up interface {interface}...")
#                # Then bring it back up with the new configuration
#                result = subprocess.run(
#                    ["sudo", "ifup", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    raise Exception(f"ifup command failed: {result.stderr}")
#
#                network_restart_success = True
#                self.add_status_message(f"Successfully restarted interface {interface}")
#                # Clear error messages on success
#                self.clear_error_messages()
#
#            except Exception as e:
#                error_msg = f"Failed to restart network interface: {str(e)}"
#                self.add_error_message(error_msg)
#                success = False
#
#        # Final status message
#        if success and network_restart_success:
#            self.add_success_message("Configuration completed and network restarted successfully!")
#        elif success:
#            self.add_error_message("Configuration completed successfully, but network restart failed.")
#        else:
#            if wifi_success:
#                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
#            elif interface_success:
#                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
#            else:
#                self.add_error_message("Configuration failed completely.")
#
#        # Re-enable the UI elements
#        self.enable_ui_elements()
#
#if __name__ == "__main__":
#    app = WifiConfigApp()
#    Gtk.main()
























#WiFi Configuration Tool Prompt
#Create a Python application with a graphical user interface for configuring WiFi on a Raspberry Pi or similar Linux device. The application should allow users to:
#- Scan for available wireless networks
#- Select a network, enter credentials, and test the connection
#- Configure a static IP address
#- Save the configuration to system files
#
#Technical Requirements
#GUI Components
#- Create a Tkinter-based interface with:
#    Interface dropdown (to select wireless interface like wlan0)
#    WiFi network dropdown (populated by scanning)
#    Password field with show/hide toggle
#    IP address field with validation
#    Error and status message display areas (scrollable text widgets)
#    Scan, OK, and Cancel buttons
#- Core Functionality
#  1. Interface Detection :
#      Automatically detect wireless interfaces
#      Default to wlan0 if none found
#      Allow user selection via dropdown
#      2. Network Scanning :
#      Implement a scan button to refresh available networks
#      Sort networks by signal strength
#      Display networks in a dropdown
#      Bring up interface before scanning ( ifconfig <interface> up)
#      Handle "interface does not support scanning" errors
#  3. Connection Testing :
#      Test WiFi credentials when focus leaves password field
#      Use temporary wpa_supplicant instance for testing
#      Detect network IP range and suggest appropriate static IP
#      Show connection status in message area
#  4. IP Configuration :
#      Validate IP address format
#      Allow setting static IP with preferred last segment (default 200)
#      Update IP suggestion based on detected network
#  5. Configuration Saving :
#      Save WiFi credentials to /etc/wpa_supplicant/wpa_supplicant.conf [1]
#      Save network interface config to /etc/network/interfaces
#      Restart network interface after saving
#- UI Behavior
#  1. Field Management :
#      Disable all UI elements during operations (scanning, testing, saving)
#      Re-enable elements when operations complete
#      Clear error/message boxes when appropriate (new scan, interface change)
#      Enable OK button only when all validations pass
#  2. Threading :
#      Use background threads for network operations
#      Update UI from background threads using root.after()
#      Prevent UI freezing during operations
#  3. Keyboard Navigation :
#      Support Enter key to move between fields
#      Support Escape key to close application
#  - Implementation Details
#      Use template files for wpa_supplicant.conf and interfaces [2]
#      Use sudo for system commands requiring elevated privileges
#      Implement proper error handling and user feedback
#      Ensure clean termination of background processes
#      Support showing/hiding password with checkbox
#
#Validate all user inputs before saving
#The application should be robust against network errors, provide clear feedback to users, and ensure proper configuration of WiFi settings on Linux systems.

#import tkinter as tk
#from tkinter import messagebox, ttk, scrolledtext
#import os
#import shutil
#import subprocess
#import re
#import threading
#import ipaddress  # For IP address validation
#import time
#
#class WifiConfigApp:
#    def __init__(self, root):
#
#        # Set preferred lowest segment of IP address
#        self.preferred_ip_segment = "200"
#
#        # Get the directory where the script is located
#        script_dir = os.path.dirname(os.path.abspath(__file__))
#
#        # Define paths relative to the script location
#        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
#        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')
#
#        self.interface_path = '/etc/network/interfaces'
#        self.wifi_path = '/etc/wpa_supplicant/wpa_supplicant.conf'
#
#        self.root = root
#        self.root.title("Raspberry Pi Wi-Fi Configuration")
#        self.root.geometry("780x540")  # Increased width to accommodate wider message boxes
#
#        # Get the default background color of the root window
#        bg_color = root.cget("background")
#
#        # Lists to store interfaces and Wi-Fi networks
#        self.interfaces = []
#        self.wifi_list = []
#
#        # Create frame for form elements
#        form_frame = tk.Frame(root, padx=20, pady=20)
#        form_frame.pack(fill=tk.BOTH, expand=True)
#
#        # Interface selection dropdown
#        tk.Label(form_frame, text="Interface:").grid(row=0, column=0, sticky=tk.W, pady=5)
#        self.interface_var = tk.StringVar()
#        self.interface_dropdown = ttk.Combobox(form_frame, textvariable=self.interface_var, width=10, state="readonly")
#        self.interface_dropdown.grid(row=0, column=1, sticky=tk.W, pady=5)
#        self.interface_dropdown.bind("<<ComboboxSelected>>", lambda event: self.interface_changed())
#
#        # Wi-Fi name dropdown
#        tk.Label(form_frame, text="Wi-Fi Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
#        self.wifi_name = tk.StringVar()
#        self.wifi_dropdown = ttk.Combobox(form_frame, textvariable=self.wifi_name, width=28, state="readonly")
#        self.wifi_dropdown.grid(row=1, column=1, sticky=tk.W, pady=5)
#
#        # Scan button
#        self.scan_button = tk.Button(form_frame, text="Scan", width=5, command=self.scan_networks)
#        self.scan_button.grid(row=1, column=2, padx=5, sticky=tk.W)
#
#        # Bind Enter key to move to next field
#        self.wifi_dropdown.bind("<Return>", lambda event: self.password_entry.focus_set())
#
#        # Password field
#        tk.Label(form_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
#        self.password = tk.StringVar()
#        self.password_entry = tk.Entry(form_frame, textvariable=self.password, width=30)
#        self.password_entry.grid(row=2, column=1, sticky=tk.W, pady=5)
#
#        # Bind Enter key to move to IP address field
#        self.password_entry.bind("<Return>", lambda event: self.ip_entry.focus_set())
#
#        # Bind FocusOut to test WiFi connection
#        self.password_entry.bind("<FocusOut>", self.test_wifi_connection)
#
#        # Add a flag to track connection success
#        self.connection_successful = False
#
#        # Hide password checkbox (unchecked by default to show password)
#        self.hide_password = tk.BooleanVar(value=False)  # Default is to show password
#        self.hide_checkbox = tk.Checkbutton(form_frame, text="Hide", variable=self.hide_password,
#                                           command=self.toggle_password_visibility)
#        self.hide_checkbox.grid(row=2, column=2, padx=5, sticky=tk.W)
#
#        # IP Address field with validation
#        tk.Label(form_frame, text="IP Address:").grid(row=3, column=0, sticky=tk.W, pady=5)
#        self.ip_address = tk.StringVar(value=f"192.168.1.{self.preferred_ip_segment}")  # Default value with preferred segment
#        self.ip_entry = tk.Entry(form_frame, textvariable=self.ip_address, width=30)
#        self.ip_entry.grid(row=3, column=1, sticky=tk.W, pady=5)
#
#        # Add validation when focus leaves the IP field
#        self.ip_entry.bind("<FocusOut>", self.validate_ip_address)
#
#        # Flag to track if IP is valid
#        self.ip_valid = False
#
#        # Initialize password field visibility
#        self.toggle_password_visibility()
#
#        # Button frame
#        button_frame = tk.Frame(form_frame)
#        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
#
#        # OK button (initially disabled)
#        self.ok_button = tk.Button(button_frame, text="OK", width=10, command=self.save_config, state=tk.DISABLED)
#        self.ok_button.pack(side=tk.LEFT, padx=10)
#        self.ok_button.bind("<Return>", lambda event: self.save_config())
#
#        # Cancel button
#        self.cancel_button = tk.Button(button_frame, text="Cancel", width=10, command=self.root.destroy)
#        self.cancel_button.pack(side=tk.LEFT, padx=10)
#        self.cancel_button.bind("<Return>", lambda event: self.root.destroy())
#
#        # Error message text area (below buttons) - 1.5 times wider
#        tk.Label(form_frame, text="Errors:").grid(row=5, column=0, sticky=tk.NW, pady=(10, 0))
#        self.error_text = scrolledtext.ScrolledText(form_frame, width=80, height=6,
#                                                  wrap=tk.WORD, fg="red", bg=bg_color)
#        self.error_text.grid(row=5, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(10, 0))
#        self.error_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Status message text area (below error area) - 1.5 times wider
#        tk.Label(form_frame, text="Messages:").grid(row=6, column=0, sticky=tk.NW, pady=(5, 0))
#        self.message_text = scrolledtext.ScrolledText(form_frame, width=80, height=8,
#                                                    wrap=tk.WORD, fg="blue", bg=bg_color)
#        self.message_text.grid(row=6, column=1, columnspan=2, sticky=tk.W+tk.E, pady=(5, 0))
#        self.message_text.config(state=tk.DISABLED)  # Make it read-only
#
#        # Bind events to check if all fields have content and IP is valid
#        self.wifi_name.trace("w", self.check_fields)
#        self.password.trace("w", self.check_fields)
#        self.ip_address.trace("w", self.validate_ip_on_change)
#
#        # Bind Escape key to close the window
#        self.root.bind("<Escape>", lambda event: self.root.destroy())
#
#        # Find available interfaces and start scanning
#        self.find_interfaces()
#
#    def disable_ui_elements(self):
#        """Disable all UI elements during operations"""
#        self.interface_dropdown.config(state=tk.DISABLED)
#        self.wifi_dropdown.config(state=tk.DISABLED)
#        self.password_entry.config(state=tk.DISABLED)
#        self.ip_entry.config(state=tk.DISABLED)
#        self.scan_button.config(state=tk.DISABLED)
#        self.ok_button.config(state=tk.DISABLED)
#        self.hide_checkbox.config(state=tk.DISABLED)
#
#    def enable_ui_elements(self):
#        """Re-enable UI elements after operations"""
#        self.interface_dropdown.config(state="readonly")
#        self.wifi_dropdown.config(state="readonly")
#        self.password_entry.config(state=tk.NORMAL)
#        self.ip_entry.config(state=tk.NORMAL)
#        self.scan_button.config(state=tk.NORMAL)
#        self.hide_checkbox.config(state=tk.NORMAL)
#        # OK button state depends on field validation, so call check_fields
#        self.check_fields()
#
#    def test_wifi_connection(self, event=None):
#        """Test connection to the selected WiFi when leaving password field"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        interface = self.interface_var.get()
#
#        if not wifi_name or not password:
#            return False
#
#        # Clear error messages before starting the test
#        self.clear_error_messages()
#        self.add_status_message(f"Testing connection to {wifi_name}...")
#
#        # Disable UI elements during connection test
#        self.disable_ui_elements()
#
#        # Start connection test in a separate thread
#        threading.Thread(target=lambda: self._test_connection_thread(wifi_name, password, interface),
#                        daemon=True).start()
#        return True
#
#    def _test_connection_thread(self, wifi_name, password, interface):
#        """Background thread for testing WiFi connection"""
#        connection_success = False
#        temp_dir = "/tmp/wpa_test"
#        detected_ip_range = None
#
#        try:
#            # Create a temporary control directory for wpa_supplicant
#            os.makedirs(temp_dir, exist_ok=True)
#
#            # Start a temporary wpa_supplicant instance for testing
#            self.root.after(0, lambda: self.add_status_message("Starting temporary wpa_supplicant..."))
#
#            # Kill any existing wpa_supplicant on this interface
#            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
#            time.sleep(1)
#
#            # Start wpa_supplicant in the background
#            wpa_process = subprocess.Popen(
#                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
#                stdout=subprocess.PIPE, stderr=subprocess.PIPE
#            )
#            time.sleep(4)  # Give it time to start
#
#            # Add the network using wpa_cli
#            self.root.after(0, lambda: self.add_status_message("Adding network..."))
#            add_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'add network result:\n{add_result.stdout}'))
#
#            # Extract the network ID from the output (last line)
#            network_id = add_result.stdout.strip().split('\n')[-1]
#
#            time.sleep(1)
#
#            # Set the network SSID
#            ssid_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{ssid_result.stdout}'))
#
#            # Set the network password
#            password_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'password result:\n{password_result.stdout}'))
#
#            # Enable the network
#            self.root.after(0, lambda: self.add_status_message("Attempting to connect..."))
#            status_result = subprocess.run(
#                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
#                capture_output=True, text=True
#            )
#            self.root.after(0, lambda: self.add_status_message(f'ssid result:\n{status_result.stdout}'))
#
#            # Poll for connection status every 2 seconds, up to 20 seconds
#            max_wait_time = 20  # seconds
#            poll_interval = 2    # seconds
#            elapsed_time = 0
#
#            while elapsed_time < max_wait_time:
#                # Check connection status
#                status_result = subprocess.run(
#                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
#                    capture_output=True, text=True
#                )
#
#                # Check if we're connected
#                if "wpa_state=COMPLETED" in status_result.stdout:
#                    connection_success = True
#                    self.root.after(0, lambda: self.add_status_message("WiFi credentials are valid!"))
#
#                    # Try to get an IP address via DHCP to determine the network's IP range
#                    self.root.after(0, lambda: self.add_status_message("Requesting temporary IP to detect network range..."))
#
#                    # Run dhclient to get an IP address
#                    dhcp_result = subprocess.run(
#                        ["sudo", "dhclient", "-1", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Check the assigned IP address
#                    ip_result = subprocess.run(
#                        ["ip", "addr", "show", interface],
#                        capture_output=True, text=True
#                    )
#
#                    # Extract IP address using regex
#                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
#                    if ip_match:
#                        assigned_ip = ip_match.group(1)
#                        # Extract the network prefix (e.g., 192.168.1)
#                        ip_parts = assigned_ip.split('.')
#                        if len(ip_parts) == 4:
#                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
#                            self.root.after(0, lambda range=detected_ip_range: self.add_status_message(f"Detected network range: {range}.x"))
#
#                            # Update the IP address suggestion with preferred segment
#                            if detected_ip_range:
#                                self.root.after(0, lambda range=detected_ip_range: self.update_ip_suggestion(range))
#                    break
#
#                # Wait before checking again
#                time.sleep(poll_interval)
#                elapsed_time += poll_interval
#                self.root.after(0, lambda: self.add_status_message(f"Waiting for connection... ({elapsed_time}/{max_wait_time}s)"))
#
#            if not connection_success:
#                self.root.after(0, lambda: self.add_error_message("Failed to connect with provided credentials after timeout"))
#
#        except Exception as e:
#            error_msg = f"WiFi connection test failed: {str(e)}"
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#
#        finally:
#            # Release the DHCP lease if we requested one
#            if connection_success:
#                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)
#
#            # Clean up - terminate wpa_supplicant
#            self.root.after(0, lambda: self.add_status_message("Cleaning up test connection..."))
#            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)
#
#            # Remove temporary directory
#            try:
#                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
#            except:
#                pass
#
#            # Re-enable UI elements
#            self.root.after(0, lambda: self.enable_ui_elements())
#
#            # Update connection status and check if OK button should be enabled
#            self.root.after(0, lambda: self._update_connection_status(connection_success))
#
#    def update_ip_suggestion(self, ip_range):
#        """Update the IP address field with a suggestion based on the detected network range"""
#        suggested_ip = f"{ip_range}.{self.preferred_ip_segment}"  # Use preferred segment
#        self.ip_address.set(suggested_ip)
#        self.validate_ip_on_change()  # Validate the new IP
#
#    def _update_connection_status(self, connection_success):
#        """Update the connection status and check if OK button should be enabled"""
#        self.connection_successful = connection_success
#        self.check_fields()
#
#    def validate_ip_on_change(self, *args):
#        """Validate IP address whenever it changes (but don't show errors)"""
#        ip = self.ip_address.get()
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#            else:
#                # Invalid IP format, but don't show error yet
#                self.ip_valid = False
#
#        # Update OK button state
#        self.check_fields()
#
#    def validate_ip_address(self, event=None):
#        """Validate the IP address when focus leaves the field"""
#        ip = self.ip_address.get()
#
#        # Clear any previous IP-related error messages
#        self.clear_specific_error_messages("IP address")
#
#        # Check if IP is valid
#        try:
#            # Try to create an IPv4Address object to validate
#            ipaddress.IPv4Address(ip)
#            self.ip_valid = True
#            self.check_fields()
#            return True
#        except ValueError:
#            # If not a valid IP, check if it's a partial IP (like "192.168.")
#            if re.match(r'^(\d{1,3}\.){1,3}$', ip):
#                # It's a partial IP, which is fine while typing
#                self.ip_valid = False
#                self.check_fields()
#                return False
#            else:
#                # Invalid IP format - show error message now that focus has left
#                error_msg = f"Invalid IP address format: {ip}"
#                self.add_error_message(error_msg)
#                self.ip_valid = False
#                self.check_fields()
#                return False
#
#    def clear_specific_error_messages(self, keyword):
#        """Clear error messages containing a specific keyword"""
#        self.error_text.config(state=tk.NORMAL)
#
#        # Get all lines
#        lines = self.error_text.get(1.0, tk.END).split('\n')
#
#        # Filter out lines containing the keyword
#        filtered_lines = [line for line in lines if keyword not in line]
#
#        # Clear and reinsert filtered content
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.insert(tk.END, '\n'.join(filtered_lines))
#
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_error_message(self, message):
#        """Add an error message to the error text area"""
#        self.error_text.config(state=tk.NORMAL)  # Enable editing
#        self.error_text.insert(tk.END, message + "\n")
#        self.error_text.see(tk.END)  # Scroll to the end
#        self.error_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_error_messages(self):
#        """Clear all error messages"""
#        self.error_text.config(state=tk.NORMAL)
#        self.error_text.delete(1.0, tk.END)
#        self.error_text.config(state=tk.DISABLED)
#
#    def add_status_message(self, message):
#        """Add a status message to the message text area"""
#        self.message_text.config(state=tk.NORMAL)  # Enable editing
#        self.message_text.insert(tk.END, message + "\n")
#        self.message_text.see(tk.END)  # Scroll to the end
#        self.message_text.config(state=tk.DISABLED)  # Disable editing again
#
#    def clear_status_messages(self):
#        """Clear all status messages"""
#        self.message_text.config(state=tk.NORMAL)
#        self.message_text.delete(1.0, tk.END)
#        self.message_text.config(state=tk.DISABLED)
#
#    def interface_changed(self):
#        """Handle interface selection change"""
#        # Clear the Wi-Fi dropdown
#        self.wifi_dropdown.set('')
#        self.wifi_dropdown['values'] = []
#        self.wifi_list = []
#
#        # Clear error and message boxes
#        self.clear_error_messages()
#        self.clear_status_messages()
#
#        # Disable UI elements during scan
#        self.disable_ui_elements()
#
#        # Start scanning with the new interface
#        self.scan_networks()
#
#    def find_interfaces(self):
#        """Find available network interfaces"""
#        status_msg = "Finding network interfaces..."
#        self.add_status_message(status_msg)
#
#        # Disable UI elements during interface detection
#        self.disable_ui_elements()
#
#        # Start in a separate thread to avoid freezing the UI
#        threading.Thread(target=self._find_interfaces_thread, daemon=True).start()
#
#    def _find_interfaces_thread(self):
#        """Background thread for finding interfaces"""
#        try:
#            # Get list of wireless interfaces
#            output = subprocess.check_output(["ls", "/sys/class/net"], universal_newlines=True)
#            all_interfaces = output.strip().split()
#
#            # Filter for wireless interfaces (typically wlan*)
#            self.interfaces = [iface for iface in all_interfaces if
#                              os.path.exists(f"/sys/class/net/{iface}/wireless") or
#                              iface.startswith("wlan")]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_interface_dropdown)
#
#        except Exception as e:
#            error_msg = f"Interface detection error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.enable_ui_elements())
#
#    def _update_interface_dropdown(self):
#        """Update the interface dropdown with found interfaces"""
#        if not self.interfaces:
#            # If no wireless interfaces found, add a default one
#            self.interfaces = ["wlan0"]
#            self.add_error_message("No wireless interfaces found. Using default 'wlan0'.")
#
#        self.interface_dropdown['values'] = self.interfaces
#
#        # Try to select wlan0 by default, or the first available interface
#        default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]
#        self.interface_var.set(default_interface)
#
#        status_msg = f"Found {len(self.interfaces)} wireless interfaces"
#        self.add_status_message(status_msg)
#
#        # Start scanning with the selected interface
#        self.scan_networks()
#
#    def scan_networks(self):
#        """Scan for available Wi-Fi networks using selected interface"""
#        interface = self.interface_var.get()
#        if not interface:
#            return
#
#        # Clear error and message boxes
#        self.clear_error_messages()
#        self.clear_status_messages()
#
#        status_msg = f"Scanning for networks on {interface}..."
#        self.add_status_message(status_msg)
#
#        # Disable UI elements during scan
#        self.disable_ui_elements()
#
#        # Start scanning in a separate thread to avoid freezing the UI
#        threading.Thread(target=lambda: self._scan_thread(interface), daemon=True).start()
#
#    def _scan_thread(self, interface):
#        """Background thread for network scanning"""
#        try:
#            # First bring up the interface to ensure it's active
#            self.root.after(0, lambda: self.add_status_message(f"Bringing up interface {interface}..."))
#            ifconfig_result=subprocess.run(["sudo", "ifconfig", interface, "up"], capture_output=True, text=True, check=True)
#            time.sleep(4)  # Give it time to initialize
#
#            # Run iwlist scan on the selected interface
#            self.root.after(0, lambda: self.add_status_message(f"Scanning for networks..."))
#            iwlist_result = subprocess.check_output(["sudo", "iwlist", interface, "scan"], universal_newlines=True)
#            #self.root.after(0, lambda: self.add_status_message(f'iwlist scan result:\n{iwlist_result}'))
#
#            # Extract networks and their signal levels
#            networks_with_signal = []
#
#            # Split the iwlist_result by "Cell" to process each network separately
#            cells = iwlist_result.split("Cell ")
#
#            for cell in cells[1:]:  # Skip the first element (header)
#                essid_match = re.search(r'ESSID:"(.*?)"', cell)
#                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
#
#                if essid_match and signal_match:
#                    essid = essid_match.group(1)
#
#                    # Skip empty or null-filled SSIDs
#                    if not essid or '\\x00' in essid:
#                        continue
#
#                    signal_level = int(signal_match.group(1))
#                    networks_with_signal.append((essid, signal_level))
#
#            # Sort networks by signal strength (highest first)
#            networks_with_signal.sort(key=lambda x: x[1], reverse=True)
#
#            # Extract just the network names, keeping the sorted order
#            self.wifi_list = [network[0] for network in networks_with_signal]
#
#            # Update the dropdown on the main thread
#            self.root.after(0, self._update_dropdown)
#
#        except subprocess.CalledProcessError as e:
#            error_msg = f"Scan error: {e.stderr if hasattr(e, 'stderr') else str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.enable_ui_elements())
#        except Exception as e:
#            error_msg = f"Scan error: {str(e)}"
#            # Update error message on the main thread
#            self.root.after(0, lambda: self.add_error_message(error_msg))
#            self.root.after(0, lambda: self.enable_ui_elements())
#
#    def _update_dropdown(self):
#        """Update the dropdown with found networks"""
#        self.wifi_dropdown['values'] = self.wifi_list
#
#        if self.wifi_list:
#            self.wifi_dropdown.current(0)  # Select the first (strongest) network
#            status_msg = f"Found {len(self.wifi_list)} networks"
#            self.add_status_message(status_msg)
#        else:
#            error_msg = "No networks found"
#            self.add_error_message(error_msg)
#
#        # Re-enable UI elements
#        self.enable_ui_elements()
#
#    def toggle_password_visibility(self):
#        """Toggle password visibility based on checkbox state"""
#        if self.hide_password.get():
#            self.password_entry.config(show="*")
#        else:
#            self.password_entry.config(show="")
#
#    def check_fields(self, *args):
#        """Enable OK button only if all fields have content, IP is valid, and connection was successful"""
#        if (self.wifi_name.get() and
#            self.password.get() and
#            self.ip_address.get() and
#            self.ip_valid and
#            self.connection_successful):
#            self.ok_button.config(state=tk.NORMAL)
#        else:
#            self.ok_button.config(state=tk.DISABLED)
#
#    def save_config(self):
#        """Save the Wi-Fi configuration to the specified file"""
#        wifi_name = self.wifi_name.get()
#        password = self.password.get()
#        ip_address = self.ip_address.get()
#        interface = self.interface_var.get()
#
#        # Temporarily disable the OK button during processing
#        self.disable_ui_elements()
#
#        success = True
#        wifi_success = False
#        interface_success = False
#        network_restart_success = False
#
#        try:
#            # Read the template wifi_file
#            with open(self.temp_wifi_path, 'r') as file:
#                wifi_content = file.read()
#
#            # Replace placeholders with user input
#            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
#            wifi_content = wifi_content.replace("<password>", password)
#
#            # Create a temporary file with the content
#            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
#            with open(temp_wifi_file, 'w') as file:
#                file.write(wifi_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_wifi_file, self.wifi_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_wifi_file)
#
#            wifi_success = True
#            status_msg = f"Wi-Fi configuration saved to {self.wifi_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        try:
#            # Read and update the interface template
#            with open(self.temp_interface_path, 'r') as file:
#                interface_content = file.read()
#
#            # Replace IP address placeholder with user input
#            interface_content = interface_content.replace("<address>", ip_address)
#
#            # Create a temporary file with the content
#            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
#            with open(temp_interface_file, 'w') as file:
#                file.write(interface_content)
#
#            # Use sudo to copy the file to the destination
#            result = subprocess.run(
#                ["sudo", "cp", temp_interface_file, self.interface_path],
#                capture_output=True, text=True
#            )
#
#            if result.returncode != 0:
#                raise Exception(f"sudo cp command failed: {result.stderr}")
#
#            # Clean up the temporary file
#            os.remove(temp_interface_file)
#
#            interface_success = True
#            status_msg = f"Network interface configuration saved to {self.interface_path}"
#            self.add_status_message(status_msg)
#            # Clear error messages on success
#            if not wifi_success:  # Only clear if not already cleared
#                self.clear_error_messages()
#
#        except Exception as e:
#            error_msg = f"Failed to save interface configuration: {str(e)}"
#            self.add_error_message(error_msg)
#            success = False
#
#        # If both configurations were successful, restart the network interface
#        if wifi_success and interface_success:
#            try:
#                self.add_status_message(f"Bringing down interface {interface}...")
#                # First bring down the interface
#                result = subprocess.run(
#                    ["sudo", "ifdown", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    self.add_status_message(f"Warning: ifdown returned: {result.stderr}")
#
#                self.add_status_message(f"Bringing up interface {interface}...")
#                # Then bring it back up with the new configuration
#                result = subprocess.run(
#                    ["sudo", "ifup", interface],
#                    capture_output=True, text=True
#                )
#
#                if result.returncode != 0:
#                    raise Exception(f"ifup command failed: {result.stderr}")
#
#                network_restart_success = True
#                self.add_status_message(f"Successfully restarted interface {interface}")
#                # Clear error messages on success
#                self.clear_error_messages()
#
#            except Exception as e:
#                error_msg = f"Failed to restart network interface: {str(e)}"
#                self.add_error_message(error_msg)
#                success = False
#
#        # Final status message
#        if success and network_restart_success:
#            self.add_status_message("Configuration completed and network restarted successfully!")
#        elif success:
#            self.add_error_message("Configuration completed successfully, but network restart failed.")
#        else:
#            if wifi_success:
#                self.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
#            elif interface_success:
#                self.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
#            else:
#                self.add_error_message("Configuration failed completely.")
#
#        # Re-enable the UI elements
#        self.enable_ui_elements()
#
#if __name__ == "__main__":
#    root = tk.Tk()
#    app = WifiConfigApp(root)
#    root.mainloop()
