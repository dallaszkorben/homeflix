#!/usr/bin/env python3

# Code generated by Amazon Q with the  below prompt:
#
#Prompt for GTK WiFi Configuration Tool
#
#Create a Python application using GTK3 that allows users to configure WiFi settings on a Raspberry Pi. The application should provide a graphical interface for selecting wireless interfaces, scanning for available networks, connecting to a selected network, and configuring a static IP address.
#
#Core Requirements
#    1. Interface Selection :
#      - Automatically detect available wireless interfaces (e.g., wlan0)
#      - Allow users to select an interface from a dropdown menu
#    2. Network Scanning :
#      - Provide a "Scan" button to search for available WiFi networks
#      - Display networks sorted by signal strength
#      - Allow selection of a network from a dropdown menu
#    3. Connection Testing :
#      - Test WiFi credentials when the user leaves the password field
#      - Detect the network's IP range during the test
#      - Show connection status in a message area
#    4. IP Configuration :
#      - IP Address field should start empty and inactive
#      - Activate and auto-fill the IP field only after a successful connection test
#      - Deactivate the IP field when interface/WiFi selection changes or scan is clicked
#      - Validate IP address format
#    5. Configuration Saving :
#      - Save WiFi credentials to /etc/wpa_supplicant/wpa_supplicant.conf
#      - Save network configuration to /etc/network/interfaces
#      - Restart the network interface to apply changes
#UI Layout
#    Create a clean, organized interface with:
#      - Dropdown menus for interface and WiFi network selection
#      - Password field with show/hide toggle
#      - IP address field
#      - OK and Cancel buttons
#      - Separate areas for error messages (red text) and status messages (blue text)
#      - Success messages should appear in bold green text
#Specific Behaviors
#    1. The OK button should only be enabled when:
#       A WiFi network is selected
#       Password field is not empty
#       IP Address field is active
#       IP Address is valid
#    2. When clicking the OK button:
#       The IP Address field should remain active (not disabled)
#       All other UI elements should be temporarily disabled during processing
#    3. Error and status message areas:
#       Both should have labels ("Errors:" and "Messages:") that are left-aligned with each other
#       Text areas should start at the same horizontal position
#Technical Requirements
#    - Use Python 3 with GTK 3 (gi.repository)
#    - Run network operations in separate threads to avoid freezing the UI
#    - Use GLib.idle_add() for thread-safe UI updates
#    - Handle errors gracefully with appropriate error messages
#    - Include proper cleanup of temporary files and processes
#
#The application should be designed for a Raspberry Pi environment but should work on any Linux system with the appropriate dependencies installed.

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, Pango
import os
import shutil
import subprocess
import re
import threading
import ipaddress
import time
import requests
import json
import time
from datetime import datetime, timedelta

class Message:

    def __init__(self):
        self.error_text = Gtk.TextView()
        self.error_text.set_editable(False)
        self.error_text.set_wrap_mode(Gtk.WrapMode.WORD)
        self.error_buffer = self.error_text.get_buffer()
        error_tag = self.error_buffer.create_tag("error", foreground="red", size_points=8)

        self.message_text = Gtk.TextView()
        self.message_text.set_editable(False)
        self.message_text.set_wrap_mode(Gtk.WrapMode.WORD)
        self.message_buffer = self.message_text.get_buffer()
        message_tag = self.message_buffer.create_tag("message", foreground="blue", size_points=8)
        success_tag = self.message_buffer.create_tag("success", foreground="green", size_points=8, weight=Pango.Weight.BOLD)

    def _clear_specific_error_messages(self, keyword):
        """Clear error messages containing a specific keyword"""
        text = self.error_buffer.get_text(
            self.error_buffer.get_start_iter(),
            self.error_buffer.get_end_iter(),
            True
        )

        # Filter out lines containing the keyword
        lines = text.split('\n')
        filtered_lines = [line for line in lines if keyword not in line]

        # Clear and reinsert filtered content
        self.error_buffer.set_text('\n'.join(filtered_lines))

    def clear_specific_error_messages(self, keyword):
        """Clear error messages containing a specific keyword"""
        GLib.idle_add(self._clear_specific_error_messages, keyword)

    def _add_error_message(self, message):
        """Add an error message to the error text area"""
        end_iter = self.error_buffer.get_end_iter()
        self.error_buffer.insert_with_tags_by_name(end_iter, message + "\n", "error")

        # Scroll to the end
        mark = self.error_buffer.create_mark("end", self.error_buffer.get_end_iter(), False)
        self.error_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def add_error_message(self, message):
        """Add an error message to the error text area"""
        GLib.idle_add(self._add_error_message, message)

    def _clear_error_messages(self):
        """Clear all error messages"""
        self.error_buffer.set_text("")

    def clear_error_messages(self):
        """Clear all error messages"""
        GLib.idle_add(self._clear_error_messages)

    # ---

    def _add_status_message(self, message):
        """Add a status message to the message text area"""
        end_iter = self.message_buffer.get_end_iter()
        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "message")

        # Scroll to the end
        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def add_status_message(self, message):
        """Add a status message to the message text area"""
        GLib.idle_add(self._add_status_message, message)

    def _add_success_message(self, message):
        """Add a success message to the message text area with green bold text"""
        end_iter = self.message_buffer.get_end_iter()
        self.message_buffer.insert_with_tags_by_name(end_iter, message + "\n", "success")

        # Scroll to the end
        mark = self.message_buffer.create_mark("end", self.message_buffer.get_end_iter(), False)
        self.message_text.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def add_success_message(self, message):
        """Add a success message to the message text area with green bold text"""
        GLib.idle_add(self._add_success_message, message)

    def _clear_status_messages(self):
        """Clear all status messages"""
        self.message_buffer.set_text("")

    def clear_status_messages(self):
        """Clear all status messages"""
        GLib.idle_add(self._clear_status_messages)

class Interface:
    def __init__(self, message):
        self.message = message

    def get_configuration(self):
        try:
            with open(WifiConfigApp.INTERFACE_PATH, 'r') as file:
                content = file.read()
            interface = None

            # Parse the interfaces file
            lines = content.split('\n')
            static_section = False
            for line in lines:
                line = line.strip()
                # Look for static ip section
                if '# static ip' in line:
                    static_section = True
                    continue
                # Look for interface definition in static section
                if static_section and line.startswith('iface'):
                    parts = line.split()
                    if len(parts) >= 2:
                        interface = parts[1]
                    break
            return interface

        except Exception as e:
            self.message.add_error_message(f"Error reading interfaces file: {e}")
            return None

class WifiNetwork:
    def __init__(self, message):
        self.message = message

    def get_configuration(self):
        try:
            with open(WifiConfigApp.WIFI_PATH, 'r') as file:
                content = file.read()

            # Look for ssid and psk in the file
            ssid_match = re.search(r'ssid="(.*?)"', content)
            psk_match = re.search(r'psk="(.*?)"', content)

            if ssid_match and psk_match:
                ssid = ssid_match.group(1)
                password = psk_match.group(1)
                return ssid, password

            return None, None

        except Exception as e:
            self.message.add_error_message(f"Error reading interfaces file: {e}")
            return None


class WifiConfigApp:
    INTERFACE_PATH = '/etc/network/interfaces'
    WIFI_PATH = '/etc/wpa_supplicant/wpa_supplicant.conf'
    PREFERED_IP_SEGMENT = "200"

    def __init__(self):
        # Set preferred lowest segment of IP address
        self.preferred_ip_segment = "200"

        # Server health check endpoint
        self.health_check_endpoint = "/info/isAlive"

        # Get the directory where the script is located
        script_dir = os.path.dirname(os.path.abspath(__file__))

        # Define paths relative to the script location
        self.temp_interface_path = os.path.join(script_dir, 'templates', 'interfaces')
        self.temp_wifi_path = os.path.join(script_dir, 'templates', 'wpa_supplicant.conf')

        self._block_interface_changed = False

        # Lists to store interfaces and Wi-Fi networks
        self.interfaces = []
        self.wifi_list = []

        # Add a flag to track connection success
        self.connection_successful = False

        # Flag to track if IP is valid
        self.ip_valid = False

        self.message = Message()
        self.interface = Interface(self.message)
        self.wifi_network = WifiNetwork(self.message)

        # Build the UI
        self.build_ui()

        # Find available interfaces and start scanning
        self.collect_interfaces()


    def build_ui(self):
        # Create main window
        self.window = Gtk.Window(title="Raspberry Pi Wi-Fi Configuration")
        self.window.set_default_size(780, 540)
        self.window.connect("destroy", Gtk.main_quit)

        # Create main container
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.set_margin_start(20)
        main_box.set_margin_end(20)
        main_box.set_margin_top(20)
        main_box.set_margin_bottom(20)
        self.window.add(main_box)

        # Create form grid
        form_grid = Gtk.Grid()
        form_grid.set_column_spacing(10)
        form_grid.set_row_spacing(10)
        main_box.pack_start(form_grid, False, False, 0)

        # Interface selection
        interface_label = Gtk.Label(label="Interface:")
        interface_label.set_halign(Gtk.Align.START)
        form_grid.attach(interface_label, 0, 0, 1, 1)

        # Interface combo
        self.interface_combo = Gtk.ComboBoxText()
        self.interface_combo.set_sensitive(False)   # Initially disabled
        form_grid.attach(self.interface_combo, 1, 0, 1, 1)
#        self.interface_combo.connect("changed", self.interface_changed)

        # Wi-Fi name selection
        wifi_label = Gtk.Label(label="Wi-Fi Name:")
        wifi_label.set_halign(Gtk.Align.START)
        form_grid.attach(wifi_label, 0, 1, 1, 1)

        # Wi-Fi combo
        self.wifi_store = Gtk.ListStore(str, int)
        self.wifi_combo = Gtk.ComboBox.new_with_model(self.wifi_store)
        self.wifi_combo.set_sensitive(False)    # Initially disabled
        renderer_text = Gtk.CellRendererText()
        self.wifi_combo.pack_start(renderer_text, True)

        def format_wifi_text(column, cell, model, iter):
            essid = model[iter][0]
            signal = model[iter][1]
            cell.set_property('text', f"{essid} ({signal} dBm)")
        self.wifi_combo.set_cell_data_func(renderer_text, format_wifi_text)
        form_grid.attach(self.wifi_combo, 1, 1, 1, 1)
        self.wifi_combo.connect("changed", self.wifi_changed)

        # Scan button
        self.scan_button = Gtk.Button(label="Scan")
        self.scan_button.connect("clicked", self.on_scan_clicked)
        form_grid.attach(self.scan_button, 2, 1, 1, 1)
        self.scan_button.set_sensitive(False)  # Initially disabled

        # Password field
        password_label = Gtk.Label(label="Password:")
        password_label.set_halign(Gtk.Align.START)
        form_grid.attach(password_label, 0, 2, 1, 1)

        self.password_entry = Gtk.Entry()
        self.password_entry.set_width_chars(30)
        self.password_entry.set_text("")
        self.password_entry.set_sensitive(False) # Initially disabled
        form_grid.attach(self.password_entry, 1, 2, 1, 1)

        # Handle Enter key in password field
        self.password_entry.connect("focus-in-event", self.focus_in_password_entry)
        self.password_entry.connect("focus-out-event", self.focus_out_password_entry)
        self.password_entry.connect("changed", self.password_changed)

        # Hide password checkbox
        self.hide_password = Gtk.CheckButton(label="Hide")
        self.hide_password.connect("toggled", self.toggle_password_visibility)
        form_grid.attach(self.hide_password, 2, 2, 1, 1)

        # IP Address field
        ip_label = Gtk.Label(label="IP Address:")
        ip_label.set_halign(Gtk.Align.START)
        form_grid.attach(ip_label, 0, 3, 1, 1)

        self.ip_entry = Gtk.Entry()
        self.ip_entry.set_width_chars(30)
        self.ip_entry.set_text("")
        self.ip_entry.set_sensitive(False) # Initially disabled
        form_grid.attach(self.ip_entry, 1, 3, 1, 1)
        self.ip_entry.connect("changed", self.ip_changed)
        self.ip_entry.connect("focus-in-event", self.focus_in_ip_entry)

        # Button box
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        button_box.set_halign(Gtk.Align.CENTER)
        button_box.set_margin_top(10)
        main_box.pack_start(button_box, False, False, 0)

        # OK button
        self.ok_button = Gtk.Button(label="OK")
        self.ok_button.connect("clicked", self.on_ok_clicked)
        self.ok_button.set_sensitive(False)  # Initially disabled
        button_box.pack_start(self.ok_button, False, False, 0)

        # Cancel button
        self.cancel_button = Gtk.Button(label="Cancel")
        self.cancel_button.connect("clicked", Gtk.main_quit)
        self.cancel_button.set_sensitive(False)
        button_box.pack_start(self.cancel_button, False, False, 0)

        # Create a grid for the text areas
        text_grid = Gtk.Grid()
        text_grid.set_column_spacing(10)
        text_grid.set_row_spacing(10)
        main_box.pack_start(text_grid, True, True, 0)

        # Create a fixed-width label container for consistent alignment
        label_width = 80

        # Status message label with fixed width container
        message_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        message_label_box.set_size_request(label_width, -1)
#        text_grid.attach(message_label_box, 0, 1, 1, 1)
        text_grid.attach(message_label_box, 0, 0, 1, 1)

        message_label = Gtk.Label(label="Messages:")
        message_label.set_halign(Gtk.Align.START)  # Left align within the box
        message_label.set_valign(Gtk.Align.START)
        message_label_box.pack_start(message_label, False, False, 0)

        # Status message text area
        scrolled_message = Gtk.ScrolledWindow()
        scrolled_message.set_hexpand(True)
        scrolled_message.set_vexpand(True)
        scrolled_message.set_min_content_height(250)
#        text_grid.attach(scrolled_message, 1, 1, 1, 1)
        text_grid.attach(scrolled_message, 1, 0, 1, 1)

        scrolled_message.add(self.message.message_text)





        # Error message label with fixed width container
        self.error_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        self.error_label_box.set_size_request(label_width, -1)
#        text_grid.attach(self.error_label_box, 0, 0, 1, 1)
        text_grid.attach(self.error_label_box, 0, 1, 1, 1)

        error_label = Gtk.Label(label="Errors:")
        error_label.set_halign(Gtk.Align.START)  # Left align within the box
        error_label.set_valign(Gtk.Align.START)
        self.error_label_box.pack_start(error_label, False, False, 0)

        # Error message text area
        scrolled_error = Gtk.ScrolledWindow()
        scrolled_error.set_hexpand(True)
        scrolled_error.set_vexpand(True)
        scrolled_error.set_min_content_height(100)
#        text_grid.attach(scrolled_error, 1, 0, 1, 1)
        text_grid.attach(scrolled_error, 1, 1, 1, 1)

        scrolled_error.add(self.message.error_text)






        # Initialize password field visibility
        self.toggle_password_visibility(self.hide_password)

        # Show all widgets
        self.window.show_all()


    # ---------------------
    # 1. Collect Interfaces
    # ---------------------
    def collect_interfaces(self):
        """Find available network interfaces - collect wifi networks - collect password in a cascade"""

        # Clear error and message boxes
        self.message.clear_error_messages()
        self.message.clear_status_messages()

        status_msg = "Collect network interfaces..."
        self.message.add_status_message(status_msg)

        # Start in a separate thread to avoid freezing the UI
        threading.Thread(target=self._collect_interfaces_thread, daemon=True).start()

    def _collect_interfaces_thread(self):
        """Background thread for finding interfaces"""
        try:
            # Get list of wireless interfaces using iwconfig
            output = subprocess.check_output(["iwconfig"], universal_newlines=True, stderr=subprocess.STDOUT)

            # Parse output to find wireless interfaces
            self.interfaces = []
            for line in output.split('\n'):
                if line and not line.startswith(' '):  # Only process lines starting with interface names
                    iface = line.split()[0]
                    if 'no wireless extensions' not in line:
                        self.interfaces.append(iface)

            # Update the dropdown on the main thread
            GLib.idle_add(self._update_interface_dropdown)

        except Exception as e:
            error_msg = f"Interface detection error: {str(e)}"
            # Update error message on the main thread
            self.message.add_error_message(error_msg)
            GLib.idle_add(lambda: self.enable_ui_elements())

    def _update_interface_dropdown(self):
        """Update the interface dropdown with found interfaces"""

        if not self.interfaces:
            # If no wireless interfaces found, add a default one
            self.interfaces = ["wlan0"]
            self.message.add_error_message("  No wireless interfaces found. Using default 'wlan0'.")

        # Clear and populate the interface dropdown
        self.interface_combo.remove_all()
        for iface in self.interfaces:
            self.interface_combo.append_text(iface)

        # Set the flag to block the signal handler
        self._block_interface_changed = True

        try:
            # Get previously configured interface
            configured_interface = self.interface.get_configuration()

            # Select configured interface if it exists, otherwise use wlan0 or first available
            if configured_interface and configured_interface in self.interfaces:
                default_interface = configured_interface
            else:
                default_interface = "wlan0" if "wlan0" in self.interfaces else self.interfaces[0]

            index = self.interfaces.index(default_interface)
            self.interface_combo.set_active(index)
        finally:
            # Make sure to always unblock the signal handler
            self._block_interface_changed = False

        status_msg = f"    Found {len(self.interfaces)} wireless interfaces: {default_interface}"
        self.message.add_status_message(status_msg)

        # Start scanning with the selected interface
        self.collect_networks()

    # -------------------
    # 2. Collect Networks
    # -------------------
    def collect_networks(self):
        """Scan for available Wi-Fi networks using selected interface"""

        interface = self.interface_combo.get_active_text()
        if not interface:
            return

        status_msg = f"Scanning for networks on {interface}..."
        self.message.add_status_message(status_msg)

        # Start scanning in a separate thread to avoid freezing the UI
        threading.Thread(target=lambda: self._collect_network_thread(interface), daemon=True).start()

    def _collect_network_thread(self, interface):
        """Background thread for network scanning"""

        # Set start time for timeout
        start_time = datetime.now()
        timeout = timedelta(seconds=15)
        success = False

        try:
            # First bring up the interface to ensure it's active
            self.message.add_status_message(f"    Bringing up interface {interface}...")

            ifconfig_result=subprocess.run(["sudo", "ifconfig", interface, "up"], capture_output=True, text=True, check=True)

            # Run iwlist scan on the selected interface
            self.message.add_status_message(f"    Scanning for networks...")

            # Keep trying until success or timeout
            while not success and (datetime.now() - start_time) < timeout:
                try:
                    iwlist_result = subprocess.check_output(["sudo", "iwlist", interface, "scan"], stderr=subprocess.STDOUT, universal_newlines=True)
                    success = True  # If we get here, the command succeeded
                except subprocess.CalledProcessError as e:
                    time.sleep(1.0)  # Wait half a second before retrying
                    continue

            # If we exited the loop due to timeout
            if not success:
                raise subprocess.CalledProcessError(
                    returncode=1,
                    cmd=["sudo", "iwlist", interface, "scan"],
                    output="",
                    stderr="Timeout after 15 seconds: Device or resource busy"
                )

            # Extract networks and their signal levels
            network_with_signal_list = []

            # Split the iwlist_result by "Cell" to process each network separately
            cells = iwlist_result.split("Cell ")

            for cell in cells[1:]:  # Skip the first element (header)
                essid_match = re.search(r'ESSID:"(.*?)"', cell)
                signal_match = re.search(r'Signal level=(-\d+) dBm', cell)
                frequency_match = re.search(r'Frequency:([\d\.]+)', cell)
                mode_match = re.search(r'Mode:([^ \s]+)', cell)
                channel_match = re.search(r'Channel:(\d+)', cell)

                if essid_match and signal_match:
                    essid = essid_match.group(1)
                    mode = mode_match.group(1)

                    # Skip empty or null-filled SSIDs
                    if not essid or '\\x00' in essid or mode != 'Master':
                        continue

                    channel = channel_match.group(1) if channel_match else 'N/A'
                    frequency = frequency_match.group(1)
                    signal_level = int(signal_match.group(1))
                    network_with_signal_list.append((essid, signal_level))

            # Sort networks by signal strength (highest first)
            network_with_signal_list.sort(key=lambda x: x[1], reverse=True)

            # Update the dropdown on the main thread
            GLib.idle_add(lambda wifi_list=network_with_signal_list: self._update_network_dropdown(wifi_list))

        except subprocess.CalledProcessError as e:
            error_msg = f"Scan error 1: {e.stderr if hasattr(e, 'stderr') else str(e)}"
            # Update error message on the main thread
            self.message.add_error_message(error_msg)
            GLib.idle_add(lambda: self.enable_ui_elements())
        except Exception as e:
            error_msg = f"Scan error 2: {str(e)}"
            # Update error message on the main thread
            self.message.add_error_message(error_msg)
            GLib.idle_add(lambda: self.enable_ui_elements())

    def _update_network_dropdown(self, wifi_list):
        """Update the dropdown with found networks"""

        # Clear the wifi dropdown
        if self.wifi_combo.get_model():
            self.wifi_combo.get_model().clear()

        # Populate the wifi dropdown
        for essid, signal in wifi_list:
            self.wifi_store.append([essid, signal])

        # Message about the found networks
        if wifi_list:
            status_msg = f"    Found {len(wifi_list)} networks"
            self.message.add_status_message(status_msg)
        else:
            error_msg = "  No networks found"
            self.message.add_error_message(error_msg)

        # Get previously configured wifi network
        configured_wifi_network, configured_wifi_password = self.wifi_network.get_configuration()

        # Select configured wifi network if it exists, otherwise use the first available
        if configured_wifi_network and any(configured_wifi_network == essid for essid, _ in wifi_list):

            status_msg = f"    Configured wifi network:\t'{configured_wifi_network}' was found in the networks around"
            self.message.add_status_message(status_msg)

            default_wifi_network = configured_wifi_network

            # Set password field to configured password if it exists
            if configured_wifi_password:
                self.password_entry.set_text(configured_wifi_password)

        else:
            default_wifi_network = wifi_list[0][0] if wifi_list else ""

            status_msg = f"    Configured wifi network:\t'{configured_wifi_network}' was NOT found in the networks around.\n\t\t\t\t\t\tThe network with strongest signal will be selected: {default_wifi_network}"
            self.message.add_status_message(status_msg)

        index = next((i for i, (essid, _) in enumerate(wifi_list) if essid == default_wifi_network), -1)
        self.wifi_combo.set_active(index)

        status_msg = f"    {index}. element from the list"
        self.message.add_status_message(status_msg)

        self.enable_all_without_ok()

        # Set focus to IP field
        self.password_entry.grab_focus()

    # ------------
    # Focus events
    # ------------

    def focus_in_password_entry(self, widget, event):
        pass
#        print(f"I'm in the Password field: widget: {widget}, event: {event}")

    def focus_out_password_entry(self, widget, event):
        """
        If I leave the Password field to IP field
            - if the IP is not full valid, then I generate IP
            - if one of the passwrod, wifi-name, interface is not selected, then focus bac to the field
        """
        pass
#        print(f"I'm out of the Password field, Widget: {widget.get_name()}")

    def focus_in_ip_entry(self, widget, event):
        """Handle focus-in event for IP entry field"""

        # Password
        password = self.password_entry.get_text()
        if not password:
            print("No password, go back to password field")

            # Set focus to password field and select its content
            self.password_entry.grab_focus()

            # Clear the IP field
            self.ip_entry.set_text("")
            return False

        # Wifi name
        active_id = self.wifi_combo.get_active()
        if active_id == -1:
            # Focus the wifi name
            self.wifi_combo.grab_focus()
            return False
        iter = self.wifi_combo.get_active_iter()
        if iter is not None:
            model = self.wifi_combo.get_model()
            wifi_name = model[iter][0]
        else:
            # Focus the wifi name
            self.wifi_combo.grab_focus()
            return False

        # Interface
        interface = self.interface_combo.get_active_text()

        # If the IP Address is not full valid, I generate new IP
        if (password and wifi_name and interface) and not self.ip_entry_full_valid():
            self.generate_recommended_ip(wifi_name, password, interface)

#        # Set focus to IP field and select its content
#        self.ip_entry.grab_focus()

        # Stay in IP field and select all text
#        self.ip_entry.select_region(0, -1)

        return False

    # -------------
    # Events
    # -------------
    def toggle_password_visibility(self, button):
        """Toggle password visibility based on checkbox state"""

        if button.get_active():
            self.password_entry.set_visibility(False)  # Hide password
        else:
            self.password_entry.set_visibility(True)   # Show password

    def on_scan_clicked(self, button):
        """Handle scan button click"""

        # Deactivate IP Address field when Scan is clicked
        self.ip_entry.set_text("")
        self.password_entry.set_text("")
        self.ip_entry.set_text("")

        self.disable_all()

        self.collect_networks()

    # ------------------------
    # Field enabling/disabling
    # ------------------------
    def enable_interface_and_wifi(self):
        self.interface_combo.set_sensitive(True)
        self.wifi_combo.set_sensitive(True)
        self.scan_button.set_sensitive(True)
        self.password_entry.set_sensitive(True)

        self.ip_entry.set_sensiteive(False)
        self.ok_button.set_sensitive(False)
        self.cancel_button.set_sensitive(True)

    def enable_all_with_ok(self):
        self.interface_combo.set_sensitive(True)
        self.wifi_combo.set_sensitive(True)
        self.scan_button.set_sensitive(True)
        self.password_entry.set_sensitive(True)
        self.ip_entry.set_sensitive(True)

        self.ok_button.set_sensitive(True)
        self.cancel_button.set_sensitive(True)

    def enable_all_without_ok(self):
        self.interface_combo.set_sensitive(True)
        self.wifi_combo.set_sensitive(True)
        self.scan_button.set_sensitive(True)
        self.password_entry.set_sensitive(True)
        self.ip_entry.set_sensitive(True)

        self.ok_button.set_sensitive(False)
        self.cancel_button.set_sensitive(True)

    def disable_all(self):
        self.interface_combo.set_sensitive(False)
        self.wifi_combo.set_sensitive(False)
        self.scan_button.set_sensitive(False)
        self.password_entry.set_sensitive(False)
        self.ip_entry.set_sensitive(False)

        self.ok_button.set_sensitive(False)
        self.cancel_button.set_sensitive(False)


    # -------------
    # Field changed
    # -------------
    def wifi_changed(self, combo):
        """Handle WiFi selection change"""

        #print('wifi changed')

        # Deactivate IP Address field when WiFi is changed
        self.ip_entry.set_text("")
        self.connection_successful = False

        # Set focus to password field and select its content
        self.password_entry.grab_focus()
        self.password_entry.select_region(0, -1)  # Select all text

    def ip_changed(self, widget):
        if self.ip_entry_full_valid():
            self.enable_all_with_ok()
        else:
            self.enable_all_without_ok()

    def password_changed(self, widget):
        if len(self.password_entry.get_text().strip()) == 0 or not self.ip_entry_full_valid():
            self.enable_all_without_ok()
        else:
            self.enable_all_with_ok()
    #-----------------
    # Control IP field
    #-----------------
    def ip_entry_full_valid(self):
        ip = self.ip_entry.get_text()

        try:
            # Try to create an IPv4Address object to validate
            ret=ipaddress.IPv4Address(ip)
            ip_valid = True
        except ValueError:
            ip_valid = False
        return ip_valid

    def generate_recommended_ip(self, wifi_name, password, interface):
        """Get suggested IP address for the given WiFi network"""

        # Disable UI elements during connection test
        self.disable_all()

        # Clear error messages before starting the test
#        self.message.clear_status_messages()
        self.message.clear_error_messages()
        self.message.add_status_message(f"---------------------------------------------------")
        self.message.add_status_message(f"Generate recommended IP to '{wifi_name}' network...")

        # Start connection test in a separate thread
        threading.Thread(target=lambda: self._generate_recommended_ip_thread(wifi_name, password, interface), daemon=True).start()

        return True


    def _generate_recommended_ip_thread(self, wifi_name, password, interface):
        """Background thread for testing WiFi connection"""

        connection_success = False
        temp_dir = "/tmp/wpa_test"
        detected_ip_range = None

        try:
            # Create a temporary control directory for wpa_supplicant
            os.makedirs(temp_dir, exist_ok=True)

# ---

            # Start a temporary wpa_supplicant instance for testing
            self.message.add_status_message("  • Starting temporary wpa_supplicant...")

            # Kill any existing wpa_supplicant on this interface
            subprocess.run(["sudo", "killall", "-q", "wpa_supplicant"], capture_output=True, text=True)
            time.sleep(1)

            # Start wpa_supplicant in the background
            wpa_process_result = subprocess.run(
                ["sudo", "wpa_supplicant", "-B", "-i", interface, "-C", temp_dir, "-f", "/tmp/wpa_test.log"],
                capture_output=True, text=True
            )
            self.message.add_status_message(f"    result: {wpa_process_result.returncode}")

            time.sleep(4)  # Give it time to start

# ---

            # Add the network using wpa_cli
            self.message.add_status_message("  • Adding network...")

            add_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "add_network"],
                capture_output=True, text=True
            )
            formatted_output = add_result.stdout.replace('\n', '\n    ').rstrip()
            self.message.add_status_message(f'    result:')
            self.message.add_status_message(f'    {formatted_output}')

            # Extract the network ID from the output (last line)
            network_id = add_result.stdout.strip().split('\n')[-1]

            time.sleep(1)

# ---

            # Set the network SSID
            self.message.add_status_message(f'  • Set network - SSSID')
            ssid_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "ssid", f"\"{wifi_name}\""],
                capture_output=True, text=True
            )
            formatted_output = ssid_result.stdout.replace('\n', '\n    ').rstrip()
            self.message.add_status_message(f'    result:')
            self.message.add_status_message(f'    {formatted_output}')

# ---

            # Set the network password
            self.message.add_status_message(f'  • Set network - Password')
            password_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "set_network", network_id, "psk", f"\"{password}\""],
                capture_output=True, text=True
            )
            formatted_output = password_result.stdout.replace('\n', '\n    ').rstrip()
            self.message.add_status_message(f'    result:')
            self.message.add_status_message(f'    {formatted_output}')

# ---

            # Enable the network
            self.message.add_status_message("  • Enable network...")
            status_result = subprocess.run(
                ["sudo", "wpa_cli", "-p", temp_dir, "enable_network", network_id],
                capture_output=True, text=True
            )
            formatted_output = status_result.stdout.replace('\n', '\n    ').rstrip()
            self.message.add_status_message(f'    result:')
            self.message.add_status_message(f'    {formatted_output}')

# ---

            # Poll for connection status every 2 seconds, up to 20 seconds
            max_wait_time = 20  # seconds
            poll_interval = 2    # seconds
            elapsed_time = 0

            self.message.add_status_message("  • Connect to network...")

            while elapsed_time < max_wait_time:
                # Check connection status
                status_result = subprocess.run(
                    ["sudo", "wpa_cli", "-p", temp_dir, "status"],
                    capture_output=True, text=True
                )

                # Check if we're connected
                if "wpa_state=COMPLETED" in status_result.stdout:
                    connection_success = True
                    self.message.add_status_message("    WiFi credentials are valid!")

                    # Try to get an IP address via DHCP to determine the network's IP range
                    self.message.add_status_message("  • Requesting temporary IP to detect network range...")

                    # Run dhclient to get an IP address
                    dhcp_result = subprocess.run(
                        ["sudo", "dhclient", "-1", interface],
                        capture_output=True, text=True
                    )

                    # Check the assigned IP address
                    ip_result = subprocess.run(
                        ["ip", "addr", "show", interface],
                        capture_output=True, text=True
                    )

                    # Extract IP address using regex
                    #192.168.50.54/24
                    ip_match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', ip_result.stdout)
                    if ip_match:

                        assigned_ip = ip_match.group(1)

                        # Extract the network prefix (e.g., 192.168.1)
                        ip_parts = assigned_ip.split('.')
                        if len(ip_parts) == 4:
                            detected_ip_range = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}"
                            self.message.add_status_message(f"    Detected network range: {detected_ip_range}.x")

                            # Update the IP address suggestion with preferred segment
                            if detected_ip_range:

                                # write out the IP
                                GLib.idle_add(lambda suggested_ip = f"{detected_ip_range}.{self.preferred_ip_segment}": self.ip_entry.set_text(suggested_ip))
                    break

                # Wait before checking again
                time.sleep(poll_interval)
                elapsed_time += poll_interval
                GLib.idle_add(lambda et=elapsed_time, mt=max_wait_time: self.message.add_status_message(f"    Waiting for connection... ({et}/{mt}s)"))

            if not connection_success:
                self.message.add_error_message("Failed to connect with provided credentials after timeout")

        except Exception as e:
            error_msg = f"WiFi connection test failed: {str(e)}"
            self.message.add_error_message(error_msg)

        finally:
            # Release the DHCP lease if we requested one
            if connection_success:
                subprocess.run(["sudo", "dhclient", "-r", interface], capture_output=True, text=True)

            # Clean up - terminate wpa_supplicant
            self.message.add_status_message("  • Cleaning up test connection...")
            subprocess.run(["sudo", "killall", "wpa_supplicant"], capture_output=True, text=True)

            # Remove temporary directory
            try:
                subprocess.run(["sudo", "rm", "-rf", temp_dir], capture_output=True, text=True)
            except:
                pass

            self.message.add_status_message("DONE")

            self.connection_successful = connection_success

            if connection_success:
                self.enable_all_with_ok()
            else:
                self.enable_all_without_ok()

    # --
    # OK
    # --
    def check_server_health(self, ip_address):
        """Check if the server is healthy by sending a GET request to the health check endpoint"""
        try:
            url = f"http://{ip_address}{self.health_check_endpoint}"
            self.message.add_status_message(f"Checking server health at {url}...")

            # Set a timeout for the request
            response = requests.get(url, timeout=10)

            # Check if the response is valid JSON
            try:
                data = response.json()
                if response.status_code == 200 and data.get("result") == True:
                    return True
                else:
                    return False
            except json.JSONDecodeError:
                self.message.add_error_message(f"Invalid JSON response from server: {response.text}")
                return False

        except requests.exceptions.RequestException as e:
            self.message.add_error_message(f"Server health check failed: {str(e)}")
            return False

    def on_ok_clicked(self, button):
        """Handle OK button click"""

        # Disable UI elements during the process
        self.disable_all()

        # Start connection test in a separate thread
        threading.Thread(target=lambda: self._on_ok_clicked_thread(), daemon=True).start()

        # Restore the IP field state after save_config re-enables UI elements
#        self.ip_entry.set_sensitive(ip_field_was_active)
#        self.check_fields()

    def _on_ok_clicked_thread(self):
        """Save the Wi-Fi configuration to the specified file"""

        iter = self.wifi_combo.get_active_iter()
        if iter is not None:
            model = self.wifi_combo.get_model()
            wifi_name = model[iter][0]
        else:
            self.password_entry.set_text("")
            self.ip_entry.set_text("")

            error_msg = f"No network was selected"
            self.message.add_error_message(error_msg)
            self.enable_all_without_ok()
            return False

        self.disable_all()

        password = self.password_entry.get_text()
        ip_address = self.ip_entry.get_text()
        interface = self.interface_combo.get_active_text()

        success = True
        wifi_success = False
        interface_success = False
        network_restart_success = False

        try:
            # Read the template wifi_file
            with open(self.temp_wifi_path, 'r') as file:
                wifi_content = file.read()

            # Replace placeholders with user input
            wifi_content = wifi_content.replace("<wifi_id>", wifi_name)
            wifi_content = wifi_content.replace("<password>", password)

            # Create a temporary file with the content
            temp_wifi_file = os.path.join(os.path.dirname(self.temp_wifi_path), 'temp_wifi.conf')
            with open(temp_wifi_file, 'w') as file:
                file.write(wifi_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_wifi_file, WifiConfigApp.WIFI_PATH],
                capture_output=True, text=True
            )
#            print(f"sudo cp {temp_wifi_file} {WifiConfigApp.WIFI_PATH}")
#            result = type('', (), {'returncode': 0})()

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_wifi_file)

            wifi_success = True
            status_msg = f"\nWi-Fi configuration saved to {WifiConfigApp.WIFI_PATH}"
            self.message.add_status_message(status_msg)

            # Clear error messages on success
            self.message.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save Wi-Fi configuration: {str(e)}"
            self.message.add_error_message(error_msg)
            success = False

        try:
            # Read and update the interface template
            with open(self.temp_interface_path, 'r') as file:
                interface_content = file.read()

            # Extract network prefix from IP address (e.g., "192.168.1" from "192.168.1.200")
            ip_parts = ip_address.split('.')
            gateway = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.1"

            # Replace IP address placeholder with user input
            interface_content = interface_content.replace("<address>", ip_address)
            interface_content = interface_content.replace("<gateway>", gateway)

            # Create a temporary file with the content
            temp_interface_file = os.path.join(os.path.dirname(self.temp_interface_path), 'temp_interface')
            with open(temp_interface_file, 'w') as file:
                file.write(interface_content)

            # Use sudo to copy the file to the destination
            result = subprocess.run(
                ["sudo", "cp", temp_interface_file, WifiConfigApp.INTERFACE_PATH],
                capture_output=True, text=True
            )
#            print(f"sudo cp {temp_interface_file} {WifiConfigApp.INTERFACE_PATH}")
#            result = type('', (), {'returncode': 0})()

            if result.returncode != 0:
                raise Exception(f"sudo cp command failed: {result.stderr}")

            # Clean up the temporary file
            os.remove(temp_interface_file)

            interface_success = True
            status_msg = f"Network interface configuration saved to {WifiConfigApp.INTERFACE_PATH}"
            self.message.add_status_message(status_msg)

            # Clear error messages on success
            if not wifi_success:  # Only clear if not already cleared
                self.message.clear_error_messages()

        except Exception as e:
            error_msg = f"Failed to save interface configuration: {str(e)}"
            self.message.add_error_message(error_msg)
            success = False

        # If both configurations were successful, restart the network interface
        if wifi_success and interface_success:
            try:
                self.message.add_status_message(f"Bringing down interface {interface}...")
                # First bring down the interface
                result = subprocess.run(
                    ["sudo", "ifdown", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    self.message.add_status_message(f"Warning: ifdown returned: {result.stderr}")

                self.message.add_status_message(f"Bringing up interface {interface}...")
                # Then bring it back up with the new configuration
                result = subprocess.run(
                    ["sudo", "ifup", interface],
                    capture_output=True, text=True
                )

                if result.returncode != 0:
                    raise Exception(f"ifup command failed: {result.stderr}")

                network_restart_success = True
                self.message.add_status_message(f"Successfully restarted interface {interface}")

                # Check server health after network restart
                if network_restart_success:
                    self.message.add_status_message("Waiting for network to stabilize...")
                    time.sleep(5)  # Give the network some time to stabilize

                    # Check server health
                    server_healthy = self.check_server_health(ip_address)
                    if server_healthy:
                        self.message.add_status_message("Server is healthy and responding!")
                    else:
                        self.add_error_message("Server health check failed. The server may not be running or reachable.")

                # Clear error messages on success
                self.message.clear_error_messages()

            except Exception as e:
                error_msg = f"Failed to restart network interface: {str(e)}"
                self.message.add_error_message(error_msg)
                success = False

        network_restart_success = True

        # Final status message
        if success and network_restart_success:
            self.message.add_success_message("Configuration completed, network restarted successfully and the server responding")
            self.enable_all_with_ok()
        elif success:
            self.message.add_error_message("Configuration completed successfully, but network restart failed.")
            self.enable_all_with_ok()
        else:
            if wifi_success:
                self.message.add_error_message("Wi-Fi configuration was successful, but interface configuration failed.")
            elif interface_success:
                self.message.add_error_message("Interface configuration was successful, but Wi-Fi configuration failed.")
            else:
                self.message.add_error_message("Configuration failed completely.")
            self.enable_all_without_ok()


if __name__ == "__main__":
    app = WifiConfigApp()
    Gtk.main()
